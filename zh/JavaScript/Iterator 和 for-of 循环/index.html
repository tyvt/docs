<!DOCTYPE html>
<html dir="ltr" lang="en-us" class="initial astro-OUAMJN2I">
	<head>
		<!-- Global Metadata --><meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Astro v2.7.0">

<link rel="icon" type="image/svg+xml" href="/docs/favicon.svg">

<link rel="sitemap" href="/sitemap.xml">

<!-- Scrollable a11y code helper -->
<script>
	Array.from(document.getElementsByTagName('pre')).forEach((element) => {
	element.setAttribute('tabindex', '0');
});
</script>

<!-- This is intentionally inlined to avoid FOUC -->
<script>
	const root = document.documentElement;
	const theme = localStorage.getItem('theme');
	if (theme === 'dark' || (!theme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
		root.classList.add('theme-dark');
	} else {
		root.classList.remove('theme-dark');
	}
</script>
		<!-- Page Metadata --><link rel="canonical" href="https://javascriptfield.github.io/docs/zh/JavaScript/Iterator%20%E5%92%8C%20for-of%20%E5%BE%AA%E7%8E%AF/">

<!-- OpenGraph Tags -->
<meta property="og:title" content="Iterator 和 for-of 循环 🚀 Documentation">
<meta property="og:type" content="article">
<meta property="og:url" content="https://javascriptfield.github.io/docs/zh/JavaScript/Iterator%20%E5%92%8C%20for-of%20%E5%BE%AA%E7%8E%AF/">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/withastro/astro/blob/main/assets/social/banner-minimal.png?raw=true">
<meta property="og:image:alt" content="astro logo on a starry expanse of space, with a purple saturn-like planet floating in the right foreground">
<meta name="description" property="og:description" content="Your website description.">
<meta property="og:site_name" content="Documentation">
		<title>
			Iterator 和 for-of 循环 🚀 Documentation
		</title>
		
		
	<link rel="stylesheet" href="/docs/assets/CSS-CSS深色模式.css" /><script type="module">const e="light";switch(e){case"light":document.getElementById("path-light").classList.remove("hide"),document.documentElement.classList.remove("theme-dark");break;case"dark":document.getElementById("path-dark").classList.remove("hide"),document.documentElement.classList.add("theme-dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&(document.documentElement.classList.add("theme-dark"),document.getElementById("path-dark").classList.remove("hide"));break}function t(){document.documentElement.classList.toggle("theme-dark"),document.getElementById("path-light").classList.toggle("hide"),document.getElementById("path-dark").classList.toggle("hide")}document.getElementById("themeIcon").addEventListener("click",t);function d(){document.querySelector("body").classList.toggle("mobile-sidebar-toggle")}document.getElementById("menu-toggle").addEventListener("click",d);
</script></head>

	<body class="astro-OUAMJN2I">
		<header class="astro-2W66RQV5">
	<a href="#article" class="sr-only focus:not-sr-only skiplink astro-DMGOOZ7Y"><span class="astro-DMGOOZ7Y">Skip to Content</span></a>
	<nav class="nav-wrapper astro-2W66RQV5" title="Top Navigation">
		<div class="menu-toggle astro-2W66RQV5">
			
<button type="button" id="menu-toggle">
  <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
  </svg>
  <span class="sr-only">Toggle sidebar</span>
</button>
		</div>
		<div class="logo flex astro-2W66RQV5">
			<a href="/docs/zh/Introduction/introduction" class="astro-2W66RQV5">
				<svg class="logo" width="40" height="40" viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg">
	<style>
		#flame {
			fill: var(--theme-text-accent);
		}

		#a {
			fill: var(--theme-text-accent);
		}
	</style>
	<title>Logo</title>
	<path id="a" fill-rule="evenodd" clip-rule="evenodd" d="M163.008 18.929c1.944 2.413 2.935 5.67 4.917 12.181l43.309 142.27a180.277 180.277 0 00-51.778-17.53l-28.198-95.29a3.67 3.67 0 00-7.042.01l-27.857 95.232a180.225 180.225 0 00-52.01 17.557l43.52-142.281c1.99-6.502 2.983-9.752 4.927-12.16a15.999 15.999 0 016.484-4.798c2.872-1.154 6.271-1.154 13.07-1.154h31.085c6.807 0 10.211 0 13.086 1.157a16.004 16.004 0 016.487 4.806z">
	</path>
	<path id="flame" fill-rule="evenodd" clip-rule="evenodd" d="M168.19 180.151c-7.139 6.105-21.39 10.268-37.804 10.268-20.147 0-37.033-6.272-41.513-14.707-1.602 4.835-1.961 10.367-1.961 13.902 0 0-1.056 17.355 11.015 29.426 0-6.268 5.081-11.349 11.349-11.349 10.743 0 10.731 9.373 10.721 16.977v.679c0 11.542 7.054 21.436 17.086 25.606a23.27 23.27 0 01-2.339-10.2c0-11.008 6.463-15.107 13.974-19.87 5.976-3.79 12.616-8.001 17.192-16.449a31.024 31.024 0 003.743-14.82c0-3.299-.513-6.479-1.463-9.463z">
	</path>
</svg>
				<h1 class="astro-2W66RQV5">Documentation</h1>
			</a>
		</div>
		<div style="flex-grow: 1;" class="astro-2W66RQV5"></div>
		


<svg id="themeIcon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="currentColor" class="astro-N5CD7LW7">
  <path id="path-light" class="hide astro-N5CD7LW7" fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd"></path>
  <path id="path-dark" class="hide astro-N5CD7LW7" d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path>
</svg>
	</nav>
</header>
		<main class="layout astro-OUAMJN2I">
			<aside id="grid-left" class="grid-sidebar astro-OUAMJN2I" title="Site Navigation">
				<nav aria-labelledby="grid-left" class="astro-KQNE5HRN">
	<ul class="nav-groups astro-KQNE5HRN">
		<li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">Introduction</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Introduction/introduction" class="astro-KQNE5HRN">
											Introduction
										</a>
									</li>
						</ul>
					</div>
				</li><li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">CSS</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/CSS深色模式" class="astro-KQNE5HRN">
											CSS深色模式
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/align-content 属性" class="astro-KQNE5HRN">
											align-content 属性
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/align-items 属性" class="astro-KQNE5HRN">
											align-items 属性
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/align-self 属性" class="astro-KQNE5HRN">
											align-self 属性
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/flex-direction 属性" class="astro-KQNE5HRN">
											flex-direction 属性
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/flex-wrap 属性" class="astro-KQNE5HRN">
											flex-wrap 属性
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/justify-content 属性" class="astro-KQNE5HRN">
											justify-content 属性
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/不规则卡片" class="astro-KQNE5HRN">
											不规则卡片
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/使用hover和attr()定制悬浮提示" class="astro-KQNE5HRN">
											使用hover和attr()定制悬浮提示
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/切角效果" class="astro-KQNE5HRN">
											切角效果
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/半透明边框" class="astro-KQNE5HRN">
											半透明边框
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/圆与椭圆" class="astro-KQNE5HRN">
											圆与椭圆
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/多边形" class="astro-KQNE5HRN">
											多边形
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/多重边框" class="astro-KQNE5HRN">
											多重边框
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/常见投影" class="astro-KQNE5HRN">
											常见投影
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/平行四边形" class="astro-KQNE5HRN">
											平行四边形
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/打字效果" class="astro-KQNE5HRN">
											打字效果
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/插入换行" class="astro-KQNE5HRN">
											插入换行
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/文本行斑马条纹" class="astro-KQNE5HRN">
											文本行斑马条纹
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/条纹进度条" class="astro-KQNE5HRN">
											条纹进度条
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/水平垂直居中的几种方式" class="astro-KQNE5HRN">
											水平垂直居中的几种方式
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/环形文字" class="astro-KQNE5HRN">
											环形文字
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/盒子模型" class="astro-KQNE5HRN">
											盒子模型
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/直角梯形" class="astro-KQNE5HRN">
											直角梯形
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/绝对底部（Sticky Footer）" class="astro-KQNE5HRN">
											绝对底部（Sticky Footer）
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/自定义单选框" class="astro-KQNE5HRN">
											自定义单选框
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/自定义复选框" class="astro-KQNE5HRN">
											自定义复选框
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/自定义开关选择器" class="astro-KQNE5HRN">
											自定义开关选择器
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/通过模糊弱化背景" class="astro-KQNE5HRN">
											通过模糊弱化背景
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/鼠标光标" class="astro-KQNE5HRN">
											鼠标光标
										</a>
									</li>
						</ul>
					</div>
				</li><li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">Git</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git分支-分支原理" class="astro-KQNE5HRN">
											Git分支-分支原理
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git分支-变基" class="astro-KQNE5HRN">
											Git分支-变基
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git分支-远程分支" class="astro-KQNE5HRN">
											Git分支-远程分支
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git分支开发工作流" class="astro-KQNE5HRN">
											Git分支开发工作流
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git分支的新建与合并" class="astro-KQNE5HRN">
											Git分支的新建与合并
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git分支管理-查看分支" class="astro-KQNE5HRN">
											Git分支管理-查看分支
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git变基合并" class="astro-KQNE5HRN">
											Git变基合并
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git基础与命令" class="astro-KQNE5HRN">
											Git基础与命令
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git工具-交互式暂存" class="astro-KQNE5HRN">
											Git工具-交互式暂存
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git工具-查看修订版本" class="astro-KQNE5HRN">
											Git工具-查看修订版本
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git工具-重写历史" class="astro-KQNE5HRN">
											Git工具-重写历史
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git工具-重置揭密" class="astro-KQNE5HRN">
											Git工具-重置揭密
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/常用Git命令清单" class="astro-KQNE5HRN">
											常用Git命令清单
										</a>
									</li>
						</ul>
					</div>
				</li><li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">Guide</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Guide/代码审查" class="astro-KQNE5HRN">
											代码审查
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Guide/代码整洁" class="astro-KQNE5HRN">
											代码整洁
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Guide/点击约束方案" class="astro-KQNE5HRN">
											点击约束方案
										</a>
									</li>
						</ul>
					</div>
				</li><li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">Interview</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Interview/面试问题集锦" class="astro-KQNE5HRN">
											面试问题集锦
										</a>
									</li>
						</ul>
					</div>
				</li><li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">JavaScript</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/ArrayBuffer" class="astro-KQNE5HRN">
											ArrayBuffer
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Class 的基本语法" class="astro-KQNE5HRN">
											Class 的基本语法
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Class 的继承" class="astro-KQNE5HRN">
											Class 的继承
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/DOM" class="astro-KQNE5HRN">
											DOM
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/ECMAScript 6 简介" class="astro-KQNE5HRN">
											ECMAScript 6 简介
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Generator 函数的异步应用" class="astro-KQNE5HRN">
											Generator 函数的异步应用
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Generator 函数的语法" class="astro-KQNE5HRN">
											Generator 函数的语法
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Iterator 和 for-of 循环" class="astro-KQNE5HRN">
											Iterator 和 for-of 循环
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Mixin" class="astro-KQNE5HRN">
											Mixin
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Module 的加载实现" class="astro-KQNE5HRN">
											Module 的加载实现
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Module 的语法" class="astro-KQNE5HRN">
											Module 的语法
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Promise 对象" class="astro-KQNE5HRN">
											Promise 对象
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Proxy" class="astro-KQNE5HRN">
											Proxy
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Reflect" class="astro-KQNE5HRN">
											Reflect
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/SIMD" class="astro-KQNE5HRN">
											SIMD
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Set 和 Map 数据结构" class="astro-KQNE5HRN">
											Set 和 Map 数据结构
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Symbol" class="astro-KQNE5HRN">
											Symbol
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/async 函数" class="astro-KQNE5HRN">
											async 函数
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/let 和 const 命令" class="astro-KQNE5HRN">
											let 和 const 命令
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/事件" class="astro-KQNE5HRN">
											事件
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/内置对象" class="astro-KQNE5HRN">
											内置对象
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/函数式编程" class="astro-KQNE5HRN">
											函数式编程
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/函数的扩展" class="astro-KQNE5HRN">
											函数的扩展
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/变量的解构赋值" class="astro-KQNE5HRN">
											变量的解构赋值
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/字符串的扩展" class="astro-KQNE5HRN">
											字符串的扩展
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/字符串的新增方法" class="astro-KQNE5HRN">
											字符串的新增方法
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/对象的扩展" class="astro-KQNE5HRN">
											对象的扩展
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/对象的新增方法" class="astro-KQNE5HRN">
											对象的新增方法
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/异步操作" class="astro-KQNE5HRN">
											异步操作
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/异步遍历器" class="astro-KQNE5HRN">
											异步遍历器
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/微信小程序" class="astro-KQNE5HRN">
											微信小程序
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/数值的扩展" class="astro-KQNE5HRN">
											数值的扩展
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/数组的扩展" class="astro-KQNE5HRN">
											数组的扩展
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/概念" class="astro-KQNE5HRN">
											概念
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/正则的扩展" class="astro-KQNE5HRN">
											正则的扩展
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/浏览器模型" class="astro-KQNE5HRN">
											浏览器模型
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/管理系统项目结构" class="astro-KQNE5HRN">
											管理系统项目结构
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/编程风格" class="astro-KQNE5HRN">
											编程风格
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/装饰器" class="astro-KQNE5HRN">
											装饰器
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/面向对象" class="astro-KQNE5HRN">
											面向对象
										</a>
									</li>
						</ul>
					</div>
				</li>
	</ul>
</nav>

<script>
	window.addEventListener('DOMContentLoaded', () => {
		var target = document.querySelector('[aria-current="page"]');
		if (target && target.offsetTop > window.innerHeight - 100) {
			document.querySelector('.nav-groups').scrollTop = target.offsetTop;
		}
	});
</script>
			</aside>
			<div id="grid-main" class="astro-OUAMJN2I">
				<article id="article" class="content astro-J75B3YUS">
	<section class="main-section astro-J75B3YUS">
		<h1 class="content-title astro-J75B3YUS" id="overview">Iterator 和 for-of 循环</h1>
		<nav class="block sm:hidden astro-J75B3YUS">
			<!-- <TableOfContents client:media="(max-width: 50em)" headings={headings} /> -->
		</nav>
		
					<h2 id="iterator遍历器的概念">Iterator（遍历器）的概念</h2>
<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>
<!-- more -->
<p>遍历器（Iterator）就是这样一种机制。<strong>它是一种接口，为各种不同的数据结构提供统一的访问机制</strong>。<strong>任何数据结构只要部署 Iterator 接口，就可以完成遍历操作</strong>（即依次处理该数据结构的所有成员）。</p>
<p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p>
<p>Iterator 的遍历过程是这样的。</p>
<p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>
<p>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p>
<p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p>
<p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p>
<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p>
<p>下面是一个模拟<code>next</code>方法返回值的例子。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> it </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">makeIterator</span><span style="color: #E1E4E8">([</span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8">]);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">it.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: "a", done: false }</span></span>
<span class="line"><span style="color: #E1E4E8">it.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: "b", done: false }</span></span>
<span class="line"><span style="color: #E1E4E8">it.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: undefined, done: true }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">makeIterator</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">array</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> nextIndex </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> nextIndex </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> array.</span><span style="color: #79B8FF">length</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">?</span><span style="color: #E1E4E8"> { value: array[nextIndex</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">], done: </span><span style="color: #79B8FF">false</span><span style="color: #E1E4E8"> }</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> { value: </span><span style="color: #79B8FF">undefined</span><span style="color: #E1E4E8">, done: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #E1E4E8">    },</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面代码定义了一个<code>makeIterator</code>函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组<code>['a', 'b']</code>执行这个函数，就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p>
<p>指针对象的<code>next</code>方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用<code>next</code>方法，指针就会指向数组的下一个成员。第一次调用，指向<code>a</code>；第二次调用，指向<code>b</code>。</p>
<p><code>next</code>方法返回一个对象，表示当前数据成员的信息。这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用<code>next</code>方法。</p>
<p>总之，调用指针对象的<code>next</code>方法，就可以遍历事先给定的数据结构。</p>
<p>对于遍历器对象来说，<code>done: false</code>和<code>value: undefined</code>属性都是可以省略的，因此上面的<code>makeIterator</code>函数可以简写成下面的形式。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">makeIterator</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">array</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> nextIndex </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> nextIndex </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> array.</span><span style="color: #79B8FF">length</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">?</span><span style="color: #E1E4E8"> { value: array[nextIndex</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">] }</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> { done: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #E1E4E8">    },</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> it </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">idMaker</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">it.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">().value; </span><span style="color: #6A737D">// 0</span></span>
<span class="line"><span style="color: #E1E4E8">it.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">().value; </span><span style="color: #6A737D">// 1</span></span>
<span class="line"><span style="color: #E1E4E8">it.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">().value; </span><span style="color: #6A737D">// 2</span></span>
<span class="line"><span style="color: #6A737D">// ...</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">idMaker</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> index </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> { value: index</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">, done: </span><span style="color: #79B8FF">false</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #E1E4E8">    },</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面的例子中，遍历器生成函数<code>idMaker</code>，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p>
<p>如果使用 TypeScript 的写法，遍历器接口（Iterable）、指针对象（Iterator）和<code>next</code>方法返回值的规格可以描述如下。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">interface</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Iterable</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  [Symbol.iterator]() </span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Iterator</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">interface</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Iterator</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">value</span><span style="color: #F97583">?:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">any</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">IterationResult</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">interface</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">IterationResult</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #FFAB70">value</span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">any</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #FFAB70">done</span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">boolean</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<h2 id="默认-iterator-接口">默认 Iterator 接口</h2>
<p>I<strong>terator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环（详见下文）</strong>。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p>
<p><strong>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”</strong>（iterable）。</p>
<p>ES6 规定，<strong>默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性</strong>，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">obj</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  [Symbol.iterator]: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">          value: </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">          done: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">        };</span></span>
<span class="line"><span style="color: #E1E4E8">      },</span></span>
<span class="line"><span style="color: #E1E4E8">    };</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>上面代码中，对象<code>obj</code>是可遍历的（iterable），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。</p>
<p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>
<p><strong>原生具备 Iterator 接口的数据结构如下。</strong></p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>下面的例子是数组的<code>Symbol.iterator</code>属性。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> arr </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [</span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"c"</span><span style="color: #E1E4E8">];</span></span>
<span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> iter </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> arr[Symbol.iterator]();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">iter.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: 'a', done: false }</span></span>
<span class="line"><span style="color: #E1E4E8">iter.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: 'b', done: false }</span></span>
<span class="line"><span style="color: #E1E4E8">iter.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: 'c', done: false }</span></span>
<span class="line"><span style="color: #E1E4E8">iter.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: undefined, done: true }</span></span></code></pre>
<p>上面代码中，变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。</p>
<p>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</p>
<p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p>
<p>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">class</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">RangeIterator</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">constructor</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">start</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">stop</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.value </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> start;</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.stop </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> stop;</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  [Symbol.iterator]() {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> value </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.value;</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (value </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.stop) {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.value</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> { done: </span><span style="color: #79B8FF">false</span><span style="color: #E1E4E8">, value: value };</span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> { done: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8">, value: </span><span style="color: #79B8FF">undefined</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">range</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">start</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">stop</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">RangeIterator</span><span style="color: #E1E4E8">(start, stop);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> value </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">range</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">)) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(value); </span><span style="color: #6A737D">// 0, 1, 2</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面代码是一个类部署 Iterator 接口的写法。<code>Symbol.iterator</code>属性对应一个函数，执行后返回当前对象的遍历器对象。</p>
<p>下面是通过遍历器实现指针结构的例子。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Obj</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">value</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.value </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> value;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.next </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">Obj</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">[Symbol.iterator] </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> iterator </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> { next: next };</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> current </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (current) {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> value </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> current.value;</span></span>
<span class="line"><span style="color: #E1E4E8">      current </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> current.next;</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> { done: </span><span style="color: #79B8FF">false</span><span style="color: #E1E4E8">, value: value };</span></span>
<span class="line"><span style="color: #E1E4E8">    } </span><span style="color: #F97583">else</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> { done: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> iterator;</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> one </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Obj</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> two </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Obj</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> three </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Obj</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">one.next </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> two;</span></span>
<span class="line"><span style="color: #E1E4E8">two.next </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> three;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> i </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> one) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(i); </span><span style="color: #6A737D">// 1, 2, 3</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面代码首先在构造函数的原型链上部署<code>Symbol.iterator</code>方法，调用该方法会返回遍历器对象<code>iterator</code>，调用该对象的<code>next</code>方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p>
<p>下面是另一个为对象添加 Iterator 接口的例子。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  data: [</span><span style="color: #9ECBFF">"hello"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"world"</span><span style="color: #E1E4E8">],</span></span>
<span class="line"><span style="color: #E1E4E8">  [Symbol.iterator]() {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">self</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> index </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (index </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> self.data.</span><span style="color: #79B8FF">length</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">          </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">            value: self.data[index</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">],</span></span>
<span class="line"><span style="color: #E1E4E8">            done: </span><span style="color: #79B8FF">false</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">          };</span></span>
<span class="line"><span style="color: #E1E4E8">        } </span><span style="color: #F97583">else</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">          </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> { value: </span><span style="color: #79B8FF">undefined</span><span style="color: #E1E4E8">, done: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #E1E4E8">        }</span></span>
<span class="line"><span style="color: #E1E4E8">      },</span></span>
<span class="line"><span style="color: #E1E4E8">    };</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>对于类似数组的对象（存在数值键名和<code>length</code>属性），部署 Iterator 接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的 Iterator 接口。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #79B8FF">NodeList</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">[Symbol.iterator] </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">Array</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">[Symbol.iterator];</span></span>
<span class="line"><span style="color: #6A737D">// 或者</span></span>
<span class="line"><span style="color: #79B8FF">NodeList</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">[Symbol.iterator] </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [][Symbol.iterator];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">[</span><span style="color: #F97583">...</span><span style="color: #E1E4E8">document.</span><span style="color: #B392F0">querySelectorAll</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"div"</span><span style="color: #E1E4E8">)]; </span><span style="color: #6A737D">// 可以执行了</span></span></code></pre>
<p>NodeList 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的<code>Symbol.iterator</code>属性，可以看到没有任何影响。</p>
<p>下面是另一个<strong>类似数组的对象调用数组的<code>Symbol.iterator</code>方法的例子</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> iterable </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"c"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  length: </span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  [Symbol.iterator]: </span><span style="color: #79B8FF">Array</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">[Symbol.iterator],</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> item </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> iterable) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(item); </span><span style="color: #6A737D">// 'a', 'b', 'c'</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>注意，<strong>普通对象部署数组的<code>Symbol.iterator</code>方法，并无效果</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> iterable </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  a: </span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  b: </span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  c: </span><span style="color: #9ECBFF">"c"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  length: </span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  [Symbol.iterator]: </span><span style="color: #79B8FF">Array</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">[Symbol.iterator],</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> item </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> iterable) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(item); </span><span style="color: #6A737D">// undefined, undefined, undefined</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">obj[Symbol.iterator] </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> () </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">[</span><span style="color: #F97583">...</span><span style="color: #E1E4E8">obj]; </span><span style="color: #6A737D">// TypeError: [] is not a function</span></span></code></pre>
<p>上面代码中，变量<code>obj</code>的<code>Symbol.iterator</code>方法对应的不是遍历器生成函数，因此报错。</p>
<p>有了遍历器接口，数据结构就可以用<code>for...of</code>循环遍历（详见下文），也可以使用<code>while</code>循环遍历。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> $iterator </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">ITERABLE</span><span style="color: #E1E4E8">[Symbol.iterator]();</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> $result </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> $iterator.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #F97583">while</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">!</span><span style="color: #E1E4E8">$result.done) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> x </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> $result.value;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// ...</span></span>
<span class="line"><span style="color: #E1E4E8">  $result </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> $iterator.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面代码中，<code>ITERABLE</code>代表某种可遍历的数据结构，<code>$iterator</code>是它的遍历器对象。遍历器对象每次移动指针（<code>next</code>方法），都检查一下返回值的<code>done</code>属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（<code>next</code>方法），不断循环。</p>
<h2 id="调用-iterator-接口的场合">调用 Iterator 接口的场合</h2>
<p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p>
<p><strong>（1）解构赋值</strong></p>
<p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> set </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Set</span><span style="color: #E1E4E8">().</span><span style="color: #B392F0">add</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">add</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">add</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"c"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> [x, y] </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> set;</span></span>
<span class="line"><span style="color: #6A737D">// x='a'; y='b'</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> [first, </span><span style="color: #F97583">...</span><span style="color: #E1E4E8">rest] </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> set;</span></span>
<span class="line"><span style="color: #6A737D">// first='a'; rest=['b','c'];</span></span></code></pre>
<p><strong>（2）扩展运算符</strong></p>
<p>扩展运算符（…）也会调用默认的 Iterator 接口。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 例一</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> str </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"hello"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">[</span><span style="color: #F97583">...</span><span style="color: #E1E4E8">str]; </span><span style="color: #6A737D">//  ['h','e','l','l','o']</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 例二</span></span>
<span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> arr </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [</span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"c"</span><span style="color: #E1E4E8">];</span></span>
<span class="line"><span style="color: #E1E4E8">[</span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">, </span><span style="color: #F97583">...</span><span style="color: #E1E4E8">arr, </span><span style="color: #9ECBFF">"d"</span><span style="color: #E1E4E8">];</span></span>
<span class="line"><span style="color: #6A737D">// ['a', 'b', 'c', 'd']</span></span></code></pre>
<p>上面代码的扩展运算符内部就调用 Iterator 接口。</p>
<p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，<strong>只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> arr </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [</span><span style="color: #F97583">...</span><span style="color: #E1E4E8">iterable];</span></span></code></pre>
<p><strong>（3）yield*</strong></p>
<p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">generator</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function*</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">yield</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">yield*</span><span style="color: #E1E4E8"> [</span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">4</span><span style="color: #E1E4E8">];</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">yield</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">5</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> iterator </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">generator</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">iterator.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: 1, done: false }</span></span>
<span class="line"><span style="color: #E1E4E8">iterator.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: 2, done: false }</span></span>
<span class="line"><span style="color: #E1E4E8">iterator.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: 3, done: false }</span></span>
<span class="line"><span style="color: #E1E4E8">iterator.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: 4, done: false }</span></span>
<span class="line"><span style="color: #E1E4E8">iterator.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: 5, done: false }</span></span>
<span class="line"><span style="color: #E1E4E8">iterator.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: undefined, done: true }</span></span></code></pre>
<p><strong>（4）其他场合</strong></p>
<p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([['a',1],['b',2]])</code>）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<h2 id="字符串的-iterator-接口">字符串的 Iterator 接口</h2>
<p><strong>字符串是一个类似数组的对象，也原生具有 Iterator 接口</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> someString </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"hi"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">typeof</span><span style="color: #E1E4E8"> someString[Symbol.iterator];</span></span>
<span class="line"><span style="color: #6A737D">// "function"</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> iterator </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> someString[Symbol.iterator]();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">iterator.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: "h", done: false }</span></span>
<span class="line"><span style="color: #E1E4E8">iterator.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: "i", done: false }</span></span>
<span class="line"><span style="color: #E1E4E8">iterator.</span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// { value: undefined, done: true }</span></span></code></pre>
<p>上面代码中，调用<code>Symbol.iterator</code>方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。</p>
<p>可以覆盖原生的<code>Symbol.iterator</code>方法，达到修改遍历器行为的目的。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> str </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">String</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"hi"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">[</span><span style="color: #F97583">...</span><span style="color: #E1E4E8">str]; </span><span style="color: #6A737D">// ["h", "i"]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">str[Symbol.iterator] </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">._first) {</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">._first </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">false</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> { value: </span><span style="color: #9ECBFF">"bye"</span><span style="color: #E1E4E8">, done: </span><span style="color: #79B8FF">false</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #E1E4E8">      } </span><span style="color: #F97583">else</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> { done: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #E1E4E8">      }</span></span>
<span class="line"><span style="color: #E1E4E8">    },</span></span>
<span class="line"><span style="color: #E1E4E8">    _first: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">[</span><span style="color: #F97583">...</span><span style="color: #E1E4E8">str]; </span><span style="color: #6A737D">// ["bye"]</span></span>
<span class="line"><span style="color: #E1E4E8">str; </span><span style="color: #6A737D">// "hi"</span></span></code></pre>
<p>上面代码中，字符串 str 的<code>Symbol.iterator</code>方法被修改了，所以扩展运算符（<code>...</code>）返回的值变成了<code>bye</code>，而字符串本身还是<code>hi</code>。</p>
<h2 id="iterator-接口与-generator-函数">Iterator 接口与 Generator 函数</h2>
<p><code>Symbol.iterator</code>方法的最简单实现，还是使用下一章要介绍的 Generator 函数。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> myIterable </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  [Symbol.iterator]: </span><span style="color: #F97583">function*</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">yield</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">yield</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">yield</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #E1E4E8">[</span><span style="color: #F97583">...</span><span style="color: #E1E4E8">myIterable] </span><span style="color: #6A737D">// [1, 2, 3]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 或者采用下面的简洁写法</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> [Symbol.iterator]() {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">yield</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'hello'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">yield</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'world'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> x </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> obj) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(x);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #6A737D">// "hello"</span></span>
<span class="line"><span style="color: #6A737D">// "world"</span></span></code></pre>
<p>上面代码中，<code>Symbol.iterator</code>方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。</p>
<h2 id="遍历器对象的-returnthrow">遍历器对象的 return()，throw()</h2>
<p>遍历器对象除了具有<code>next</code>方法，还可以具有<code>return</code>方法和<code>throw</code>方法。如果你自己写遍历器对象生成函数，那么<code>next</code>方法是必须部署的，<code>return</code>方法和<code>throw</code>方法是否部署是可选的。</p>
<p><code>return</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句），就会调用<code>return</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return</code>方法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">readLinesSync</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">file</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    [Symbol.iterator]() {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">          </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> { done: </span><span style="color: #79B8FF">false</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #E1E4E8">        },</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #B392F0">return</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">          file.</span><span style="color: #B392F0">close</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">          </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> { done: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #E1E4E8">        },</span></span>
<span class="line"><span style="color: #E1E4E8">      };</span></span>
<span class="line"><span style="color: #E1E4E8">    },</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面代码中，函数<code>readLinesSync</code>接受一个文件对象作为参数，返回一个遍历器对象，其中除了<code>next</code>方法，还部署了<code>return</code>方法。下面的两种情况，都会触发执行<code>return</code>方法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 情况一</span></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> line </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">readLinesSync</span><span style="color: #E1E4E8">(fileName)) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(line);</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">break</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 情况二</span></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> line </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">readLinesSync</span><span style="color: #E1E4E8">(fileName)) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(line);</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">throw</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Error</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面代码中，情况一输出文件的第一行以后，就会执行<code>return</code>方法，关闭这个文件；情况二会在执行<code>return</code>方法关闭文件之后，再抛出错误。</p>
<p>注意，<code>return</code>方法必须返回一个对象，这是 Generator 规格决定的。</p>
<p><code>throw</code>方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。请参阅《Generator 函数》一章。</p>
<h2 id="forof-循环">for…of 循环</h2>
<p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了<code>for...of</code>循环，<strong>作为遍历所有数据结构的统一的方法</strong>。</p>
<p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<strong><code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法</strong>。</p>
<p><code>for...of</code>循环可以使用的范围包括<strong>数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</strong></p>
<h3 id="数组">数组</h3>
<p>数组原生具备<code>iterator</code>接口（即默认部署了<code>Symbol.iterator</code>属性），<code>for...of</code>循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">arr</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [</span><span style="color: #9ECBFF">"red"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"green"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"blue"</span><span style="color: #E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> v </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> arr) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(v); </span><span style="color: #6A737D">// red green blue</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">obj</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {};</span></span>
<span class="line"><span style="color: #E1E4E8">obj[Symbol.iterator] </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> arr[Symbol.iterator].</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(arr);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> v </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> obj) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(v); </span><span style="color: #6A737D">// red green blue</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面代码中，空对象<code>obj</code>部署了数组<code>arr</code>的<code>Symbol.iterator</code>属性，结果<code>obj</code>的<code>for...of</code>循环，产生了与<code>arr</code>完全一样的结果。</p>
<p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">arr</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [</span><span style="color: #9ECBFF">"red"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"green"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"blue"</span><span style="color: #E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">arr.</span><span style="color: #B392F0">forEach</span><span style="color: #E1E4E8">(</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">element</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">index</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(element); </span><span style="color: #6A737D">// red green blue</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(index); </span><span style="color: #6A737D">// 0 1 2</span></span>
<span class="line"><span style="color: #E1E4E8">});</span></span></code></pre>
<p>JavaScript 原有的**<code>for...in</code>循环，只能获得对象的键名**，不能直接获取键值。ES6 提供<code>for...of</code>循环，允许遍历获得键值。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> arr </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [</span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"c"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"d"</span><span style="color: #E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">in</span><span style="color: #E1E4E8"> arr) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(a); </span><span style="color: #6A737D">// 0 1 2 3</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> arr) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(a); </span><span style="color: #6A737D">// a b c d</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面代码表明，<strong><code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值</strong>。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法（参见《数组的扩展》一章）。</p>
<p><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> arr </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [</span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">5</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">7</span><span style="color: #E1E4E8">];</span></span>
<span class="line"><span style="color: #E1E4E8">arr.foo </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"hello"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> i </span><span style="color: #F97583">in</span><span style="color: #E1E4E8"> arr) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(i); </span><span style="color: #6A737D">// "0", "1", "2", "foo"</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> i </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> arr) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(i); </span><span style="color: #6A737D">//  "3", "5", "7"</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面代码中，<code>for...of</code>循环不会返回数组<code>arr</code>的<code>foo</code>属性。</p>
<h3 id="set-和-map-结构">Set 和 Map 结构</h3>
<p>Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用<code>for...of</code>循环。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> engines </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Set</span><span style="color: #E1E4E8">([</span><span style="color: #9ECBFF">"Gecko"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"Trident"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"Webkit"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"Webkit"</span><span style="color: #E1E4E8">]);</span></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> e </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> engines) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(e);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #6A737D">// Gecko</span></span>
<span class="line"><span style="color: #6A737D">// Trident</span></span>
<span class="line"><span style="color: #6A737D">// Webkit</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> es6 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Map</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">es6.</span><span style="color: #B392F0">set</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"edition"</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">6</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">es6.</span><span style="color: #B392F0">set</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"committee"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"TC39"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">es6.</span><span style="color: #B392F0">set</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"standard"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"ECMA-262"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> [name, value] </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> es6) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(name </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">": "</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> value);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #6A737D">// edition: 6</span></span>
<span class="line"><span style="color: #6A737D">// committee: TC39</span></span>
<span class="line"><span style="color: #6A737D">// standard: ECMA-262</span></span></code></pre>
<p>上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> map </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Map</span><span style="color: #E1E4E8">().</span><span style="color: #B392F0">set</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">set</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> pair </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> map) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(pair);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #6A737D">// ['a', 1]</span></span>
<span class="line"><span style="color: #6A737D">// ['b', 2]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> [key, value] </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> map) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(key </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">" : "</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> value);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #6A737D">// a : 1</span></span>
<span class="line"><span style="color: #6A737D">// b : 2</span></span></code></pre>
<h3 id="计算生成的数据结构">计算生成的数据结构</h3>
<p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p>
<ul>
<li><code>entries()</code> 返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用<code>entries</code>方法。</li>
<li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li>
<li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li>
</ul>
<p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> arr </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [</span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"c"</span><span style="color: #E1E4E8">];</span></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> pair </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> arr.</span><span style="color: #B392F0">entries</span><span style="color: #E1E4E8">()) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(pair);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #6A737D">// [0, 'a']</span></span>
<span class="line"><span style="color: #6A737D">// [1, 'b']</span></span>
<span class="line"><span style="color: #6A737D">// [2, 'c']</span></span></code></pre>
<h3 id="类似数组的对象">类似数组的对象</h3>
<p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM NodeList 对象、<code>arguments</code>对象的例子。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 字符串</span></span>
<span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> str </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"hello"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> s </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> str) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(s); </span><span style="color: #6A737D">// h e l l o</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// DOM NodeList对象</span></span>
<span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> paras </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> document.</span><span style="color: #B392F0">querySelectorAll</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"p"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> p </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> paras) {</span></span>
<span class="line"><span style="color: #E1E4E8">  p.classList.</span><span style="color: #B392F0">add</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"test"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// arguments对象</span></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">printArgs</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> x </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">arguments</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(x);</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #B392F0">printArgs</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #6A737D">// 'a'</span></span>
<span class="line"><span style="color: #6A737D">// 'b'</span></span></code></pre>
<p>对于字符串来说，<code>for...of</code>循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> x </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"a</span><span style="color: #79B8FF">\uD83D\uDC0A</span><span style="color: #9ECBFF">"</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(x);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #6A737D">// 'a'</span></span>
<span class="line"><span style="color: #6A737D">// '\uD83D\uDC0A'</span></span></code></pre>
<p>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> arrayLike </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> { length: </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 报错</span></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> x </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> arrayLike) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(x);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 正确</span></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> x </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> Array.</span><span style="color: #B392F0">from</span><span style="color: #E1E4E8">(arrayLike)) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(x);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<h3 id="对象">对象</h3>
<p>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，<code>for...in</code>循环依然可以用来遍历键名。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">let</span><span style="color: #E1E4E8"> es6 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  edition: </span><span style="color: #79B8FF">6</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  committee: </span><span style="color: #9ECBFF">"TC39"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  standard: </span><span style="color: #9ECBFF">"ECMA-262"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> e </span><span style="color: #F97583">in</span><span style="color: #E1E4E8"> es6) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(e);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #6A737D">// edition</span></span>
<span class="line"><span style="color: #6A737D">// committee</span></span>
<span class="line"><span style="color: #6A737D">// standard</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> e </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> es6) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(e);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #6A737D">// TypeError: es6[Symbol.iterator] is not a function</span></span></code></pre>
<p>上面代码表示，对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错。</p>
<p>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> key </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">keys</span><span style="color: #E1E4E8">(someObject)) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(key </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">": "</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> someObject[key]);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>另一个方法是使用 Generator 函数将对象重新包装一下。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function*</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">entries</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">obj</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> key </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">keys</span><span style="color: #E1E4E8">(obj)) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">yield</span><span style="color: #E1E4E8"> [key, obj[key]];</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> [key, value] </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">entries</span><span style="color: #E1E4E8">(obj)) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(key, </span><span style="color: #9ECBFF">"->"</span><span style="color: #E1E4E8">, value);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #6A737D">// a -> 1</span></span>
<span class="line"><span style="color: #6A737D">// b -> 2</span></span>
<span class="line"><span style="color: #6A737D">// c -> 3</span></span></code></pre>
<h3 id="与其他遍历语法的比较">与其他遍历语法的比较</h3>
<p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是<code>for</code>循环。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> index </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">; index </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> myArray.</span><span style="color: #79B8FF">length</span><span style="color: #E1E4E8">; index</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(myArray[index]);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>这种写法比较麻烦，因此数组提供内置的<code>forEach</code>方法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">myArray.</span><span style="color: #B392F0">forEach</span><span style="color: #E1E4E8">(</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">value</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(value);</span></span>
<span class="line"><span style="color: #E1E4E8">});</span></span></code></pre>
<p>这种写法的问题在于，无法中途跳出<code>forEach</code>循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</p>
<p><code>for...in</code>循环可以遍历数组的键名。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> index </span><span style="color: #F97583">in</span><span style="color: #E1E4E8"> myArray) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(myArray[index]);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p><code>for...in</code>循环有几个缺点。</p>
<ul>
<li>数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</li>
<li><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li>
<li>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</li>
</ul>
<p>总之，<code>for...in</code>循环主要是为遍历对象而设计的，不适用于遍历数组。</p>
<p><code>for...of</code>循环相比上面几种做法，有一些显著的优点。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> value </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> myArray) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(value);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<ul>
<li>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。</li>
<li>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</li>
<li>提供了遍历所有数据结构的统一操作接口。</li>
</ul>
<p>下面是一个使用 break 语句，跳出<code>for...of</code>循环的例子。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> n </span><span style="color: #F97583">of</span><span style="color: #E1E4E8"> fibonacci) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (n </span><span style="color: #F97583">></span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1000</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">break</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(n);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用<code>break</code>语句跳出<code>for...of</code>循环。</p>
				
	</section>
</article>
			</div>
		</main>
	</body></html>