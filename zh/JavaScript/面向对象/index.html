<!DOCTYPE html>
<html dir="ltr" lang="en-us" class="initial astro-OUAMJN2I">
	<head>
		<!-- Global Metadata --><meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Astro v2.7.0">

<link rel="icon" type="image/svg+xml" href="/docs/favicon.svg">

<link rel="sitemap" href="/sitemap.xml">

<!-- Scrollable a11y code helper -->
<script>
	Array.from(document.getElementsByTagName('pre')).forEach((element) => {
	element.setAttribute('tabindex', '0');
});
</script>

<!-- This is intentionally inlined to avoid FOUC -->
<script>
	const root = document.documentElement;
	const theme = localStorage.getItem('theme');
	if (theme === 'dark' || (!theme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
		root.classList.add('theme-dark');
	} else {
		root.classList.remove('theme-dark');
	}
</script>
		<!-- Page Metadata --><link rel="canonical" href="https://javascriptfield.github.io/docs/zh/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

<!-- OpenGraph Tags -->
<meta property="og:title" content="面向对象编程 🚀 Documentation">
<meta property="og:type" content="article">
<meta property="og:url" content="https://javascriptfield.github.io/docs/zh/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/withastro/astro/blob/main/assets/social/banner-minimal.png?raw=true">
<meta property="og:image:alt" content="astro logo on a starry expanse of space, with a purple saturn-like planet floating in the right foreground">
<meta name="description" property="og:description" content="Your website description.">
<meta property="og:site_name" content="Documentation">
		<title>
			面向对象编程 🚀 Documentation
		</title>
		
		
	<link rel="stylesheet" href="/docs/assets/CSS-CSS深色模式.css" /><script type="module">const e="light";switch(e){case"light":document.getElementById("path-light").classList.remove("hide"),document.documentElement.classList.remove("theme-dark");break;case"dark":document.getElementById("path-dark").classList.remove("hide"),document.documentElement.classList.add("theme-dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&(document.documentElement.classList.add("theme-dark"),document.getElementById("path-dark").classList.remove("hide"));break}function t(){document.documentElement.classList.toggle("theme-dark"),document.getElementById("path-light").classList.toggle("hide"),document.getElementById("path-dark").classList.toggle("hide")}document.getElementById("themeIcon").addEventListener("click",t);function d(){document.querySelector("body").classList.toggle("mobile-sidebar-toggle")}document.getElementById("menu-toggle").addEventListener("click",d);
</script></head>

	<body class="astro-OUAMJN2I">
		<header class="astro-2W66RQV5">
	<a href="#article" class="sr-only focus:not-sr-only skiplink astro-DMGOOZ7Y"><span class="astro-DMGOOZ7Y">Skip to Content</span></a>
	<nav class="nav-wrapper astro-2W66RQV5" title="Top Navigation">
		<div class="menu-toggle astro-2W66RQV5">
			
<button type="button" id="menu-toggle">
  <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
  </svg>
  <span class="sr-only">Toggle sidebar</span>
</button>
		</div>
		<div class="logo flex astro-2W66RQV5">
			<a href="/docs/zh/Introduction/introduction" class="astro-2W66RQV5">
				<svg class="logo" width="40" height="40" viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg">
	<style>
		#flame {
			fill: var(--theme-text-accent);
		}

		#a {
			fill: var(--theme-text-accent);
		}
	</style>
	<title>Logo</title>
	<path id="a" fill-rule="evenodd" clip-rule="evenodd" d="M163.008 18.929c1.944 2.413 2.935 5.67 4.917 12.181l43.309 142.27a180.277 180.277 0 00-51.778-17.53l-28.198-95.29a3.67 3.67 0 00-7.042.01l-27.857 95.232a180.225 180.225 0 00-52.01 17.557l43.52-142.281c1.99-6.502 2.983-9.752 4.927-12.16a15.999 15.999 0 016.484-4.798c2.872-1.154 6.271-1.154 13.07-1.154h31.085c6.807 0 10.211 0 13.086 1.157a16.004 16.004 0 016.487 4.806z">
	</path>
	<path id="flame" fill-rule="evenodd" clip-rule="evenodd" d="M168.19 180.151c-7.139 6.105-21.39 10.268-37.804 10.268-20.147 0-37.033-6.272-41.513-14.707-1.602 4.835-1.961 10.367-1.961 13.902 0 0-1.056 17.355 11.015 29.426 0-6.268 5.081-11.349 11.349-11.349 10.743 0 10.731 9.373 10.721 16.977v.679c0 11.542 7.054 21.436 17.086 25.606a23.27 23.27 0 01-2.339-10.2c0-11.008 6.463-15.107 13.974-19.87 5.976-3.79 12.616-8.001 17.192-16.449a31.024 31.024 0 003.743-14.82c0-3.299-.513-6.479-1.463-9.463z">
	</path>
</svg>
				<h1 class="astro-2W66RQV5">Documentation</h1>
			</a>
		</div>
		<div style="flex-grow: 1;" class="astro-2W66RQV5"></div>
		


<svg id="themeIcon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="currentColor" class="astro-N5CD7LW7">
  <path id="path-light" class="hide astro-N5CD7LW7" fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd"></path>
  <path id="path-dark" class="hide astro-N5CD7LW7" d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path>
</svg>
	</nav>
</header>
		<main class="layout astro-OUAMJN2I">
			<aside id="grid-left" class="grid-sidebar astro-OUAMJN2I" title="Site Navigation">
				<nav aria-labelledby="grid-left" class="astro-KQNE5HRN">
	<ul class="nav-groups astro-KQNE5HRN">
		<li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">Introduction</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Introduction/introduction" class="astro-KQNE5HRN">
											Introduction
										</a>
									</li>
						</ul>
					</div>
				</li><li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">CSS</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/CSS深色模式" class="astro-KQNE5HRN">
											CSS深色模式
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/align-content 属性" class="astro-KQNE5HRN">
											align-content 属性
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/align-items 属性" class="astro-KQNE5HRN">
											align-items 属性
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/align-self 属性" class="astro-KQNE5HRN">
											align-self 属性
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/flex-direction 属性" class="astro-KQNE5HRN">
											flex-direction 属性
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/flex-wrap 属性" class="astro-KQNE5HRN">
											flex-wrap 属性
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/justify-content 属性" class="astro-KQNE5HRN">
											justify-content 属性
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/不规则卡片" class="astro-KQNE5HRN">
											不规则卡片
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/使用hover和attr()定制悬浮提示" class="astro-KQNE5HRN">
											使用hover和attr()定制悬浮提示
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/切角效果" class="astro-KQNE5HRN">
											切角效果
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/半透明边框" class="astro-KQNE5HRN">
											半透明边框
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/圆与椭圆" class="astro-KQNE5HRN">
											圆与椭圆
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/多边形" class="astro-KQNE5HRN">
											多边形
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/多重边框" class="astro-KQNE5HRN">
											多重边框
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/常见投影" class="astro-KQNE5HRN">
											常见投影
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/平行四边形" class="astro-KQNE5HRN">
											平行四边形
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/打字效果" class="astro-KQNE5HRN">
											打字效果
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/插入换行" class="astro-KQNE5HRN">
											插入换行
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/文本行斑马条纹" class="astro-KQNE5HRN">
											文本行斑马条纹
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/条纹进度条" class="astro-KQNE5HRN">
											条纹进度条
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/水平垂直居中的几种方式" class="astro-KQNE5HRN">
											水平垂直居中的几种方式
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/环形文字" class="astro-KQNE5HRN">
											环形文字
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/盒子模型" class="astro-KQNE5HRN">
											盒子模型
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/直角梯形" class="astro-KQNE5HRN">
											直角梯形
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/绝对底部（Sticky Footer）" class="astro-KQNE5HRN">
											绝对底部（Sticky Footer）
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/自定义单选框" class="astro-KQNE5HRN">
											自定义单选框
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/自定义复选框" class="astro-KQNE5HRN">
											自定义复选框
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/自定义开关选择器" class="astro-KQNE5HRN">
											自定义开关选择器
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/通过模糊弱化背景" class="astro-KQNE5HRN">
											通过模糊弱化背景
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/CSS/鼠标光标" class="astro-KQNE5HRN">
											鼠标光标
										</a>
									</li>
						</ul>
					</div>
				</li><li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">Git</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git分支-分支原理" class="astro-KQNE5HRN">
											Git分支-分支原理
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git分支-变基" class="astro-KQNE5HRN">
											Git分支-变基
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git分支-远程分支" class="astro-KQNE5HRN">
											Git分支-远程分支
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git分支开发工作流" class="astro-KQNE5HRN">
											Git分支开发工作流
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git分支的新建与合并" class="astro-KQNE5HRN">
											Git分支的新建与合并
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git分支管理-查看分支" class="astro-KQNE5HRN">
											Git分支管理-查看分支
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git变基合并" class="astro-KQNE5HRN">
											Git变基合并
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git基础与命令" class="astro-KQNE5HRN">
											Git基础与命令
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git工具-交互式暂存" class="astro-KQNE5HRN">
											Git工具-交互式暂存
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git工具-查看修订版本" class="astro-KQNE5HRN">
											Git工具-查看修订版本
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git工具-重写历史" class="astro-KQNE5HRN">
											Git工具-重写历史
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/Git工具-重置揭密" class="astro-KQNE5HRN">
											Git工具-重置揭密
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Git/常用Git命令清单" class="astro-KQNE5HRN">
											常用Git命令清单
										</a>
									</li>
						</ul>
					</div>
				</li><li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">Guide</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Guide/代码审查" class="astro-KQNE5HRN">
											代码审查
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Guide/代码整洁" class="astro-KQNE5HRN">
											代码整洁
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Guide/点击约束方案" class="astro-KQNE5HRN">
											点击约束方案
										</a>
									</li>
						</ul>
					</div>
				</li><li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">Interview</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/Interview/面试问题集锦" class="astro-KQNE5HRN">
											面试问题集锦
										</a>
									</li>
						</ul>
					</div>
				</li><li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">JavaScript</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/ArrayBuffer" class="astro-KQNE5HRN">
											ArrayBuffer
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Class 的基本语法" class="astro-KQNE5HRN">
											Class 的基本语法
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Class 的继承" class="astro-KQNE5HRN">
											Class 的继承
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/DOM" class="astro-KQNE5HRN">
											DOM
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/ECMAScript 6 简介" class="astro-KQNE5HRN">
											ECMAScript 6 简介
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Generator 函数的异步应用" class="astro-KQNE5HRN">
											Generator 函数的异步应用
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Generator 函数的语法" class="astro-KQNE5HRN">
											Generator 函数的语法
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Iterator 和 for-of 循环" class="astro-KQNE5HRN">
											Iterator 和 for-of 循环
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Mixin" class="astro-KQNE5HRN">
											Mixin
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Module 的加载实现" class="astro-KQNE5HRN">
											Module 的加载实现
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Module 的语法" class="astro-KQNE5HRN">
											Module 的语法
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Promise 对象" class="astro-KQNE5HRN">
											Promise 对象
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Proxy" class="astro-KQNE5HRN">
											Proxy
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Reflect" class="astro-KQNE5HRN">
											Reflect
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/SIMD" class="astro-KQNE5HRN">
											SIMD
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Set 和 Map 数据结构" class="astro-KQNE5HRN">
											Set 和 Map 数据结构
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/Symbol" class="astro-KQNE5HRN">
											Symbol
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/async 函数" class="astro-KQNE5HRN">
											async 函数
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/let 和 const 命令" class="astro-KQNE5HRN">
											let 和 const 命令
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/事件" class="astro-KQNE5HRN">
											事件
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/内置对象" class="astro-KQNE5HRN">
											内置对象
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/函数式编程" class="astro-KQNE5HRN">
											函数式编程
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/函数的扩展" class="astro-KQNE5HRN">
											函数的扩展
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/变量的解构赋值" class="astro-KQNE5HRN">
											变量的解构赋值
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/字符串的扩展" class="astro-KQNE5HRN">
											字符串的扩展
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/字符串的新增方法" class="astro-KQNE5HRN">
											字符串的新增方法
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/对象的扩展" class="astro-KQNE5HRN">
											对象的扩展
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/对象的新增方法" class="astro-KQNE5HRN">
											对象的新增方法
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/异步操作" class="astro-KQNE5HRN">
											异步操作
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/异步遍历器" class="astro-KQNE5HRN">
											异步遍历器
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/微信小程序" class="astro-KQNE5HRN">
											微信小程序
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/数值的扩展" class="astro-KQNE5HRN">
											数值的扩展
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/数组的扩展" class="astro-KQNE5HRN">
											数组的扩展
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/概念" class="astro-KQNE5HRN">
											概念
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/正则的扩展" class="astro-KQNE5HRN">
											正则的扩展
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/浏览器模型" class="astro-KQNE5HRN">
											浏览器模型
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/管理系统项目结构" class="astro-KQNE5HRN">
											管理系统项目结构
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/编程风格" class="astro-KQNE5HRN">
											编程风格
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/装饰器" class="astro-KQNE5HRN">
											装饰器
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/docs/zh/JavaScript/面向对象" class="astro-KQNE5HRN">
											面向对象
										</a>
									</li>
						</ul>
					</div>
				</li>
	</ul>
</nav>

<script>
	window.addEventListener('DOMContentLoaded', () => {
		var target = document.querySelector('[aria-current="page"]');
		if (target && target.offsetTop > window.innerHeight - 100) {
			document.querySelector('.nav-groups').scrollTop = target.offsetTop;
		}
	});
</script>
			</aside>
			<div id="grid-main" class="astro-OUAMJN2I">
				<article id="article" class="content astro-J75B3YUS">
	<section class="main-section astro-J75B3YUS">
		<h1 class="content-title astro-J75B3YUS" id="overview">面向对象编程</h1>
		<nav class="block sm:hidden astro-J75B3YUS">
			<!-- <TableOfContents client:media="(max-width: 50em)" headings={headings} /> -->
		</nav>
		
					<h2 id="一实例对象与-new-命令">一、实例对象与 new 命令</h2>
<h3 id="1对象是什么">1、对象是什么</h3>
<p>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>
<p>每一个对象都是<strong>功能中心</strong>，具有明确分工，可以完成<strong>接受信息、处理数据、发出信息</strong>等任务。对象<strong>可以复用</strong>，通过继承机制还<strong>可以定制</strong>。因此，面向对象编程具有<strong>灵活、代码可复用、高度模块化</strong>等特点，容易维护和开发，比起由一系列函数或指令组成的传统的<strong>过程式编程</strong>（procedural programming），更适合多人合作的<strong>大型软件项目</strong>。</p>
<p>那么，“对象”（object）到底是什么？我们从两个层次来理解。</p>
<p><strong>（1）对象是单个实物的抽象。</strong></p>
<p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当<strong>实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</strong></p>
<p><strong>（2）对象是一个容器，封装了属性（property）和方法（method）。</strong></p>
<p><strong>属性</strong>是对象的状态，<strong>方法</strong>是对象的行为（完成某种任务）。比如，我们可以把动物抽象为<code>animal</code>对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> person </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 对象</span></span>
<span class="line"><span style="color: #E1E4E8">  name: </span><span style="color: #9ECBFF">"张三"</span><span style="color: #E1E4E8">, </span><span style="color: #6A737D">// 属性</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">interest</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">// 方法(行为)</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"正在喝酒"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"><span style="color: #E1E4E8">person.</span><span style="color: #B392F0">interest</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 张三正在喝酒</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 真实世界： 有一个人，名字叫张三，他正在喝酒。</span></span>
<span class="line"><span style="color: #6A737D">// 对象模拟： 一个人抽象为一个对象person，对象是一个容器，内部封装了属性name叫张三，他正在喝酒封装成方法interest</span></span></code></pre>
<h3 id="2构造函数">2、构造函数</h3>
<p>面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。</p>
<p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是<strong>基于构造函数（constructor）和原型链（prototype）</strong>。</p>
<p>JavaScript 语言<strong>使用构造函数（constructor）作为对象的模板</strong>。</p>
<p><strong>所谓”构造函数”，就是专门用来生成实例对象的函数</strong>。</p>
<p>它就是对象的模板，描述实例对象的基本结构。</p>
<p>一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p>
<p>构造函数就是一个普通的函数，但是有自己的特征和用法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.price </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1000</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>上面代码中，<code>Vehicle</code>就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。</p>
<p>构造函数的特点有两个。</p>
<ul>
<li>函数体内部使用了<code>this</code>关键字，代表了所要生成的对象实例。</li>
<li>生成对象的时候，必须使用<code>new</code>命令。</li>
</ul>
<p>下面先介绍<code>new</code>命令。</p>
<h3 id="3new-命令">3、new 命令</h3>
<h4 id="基本用法">基本用法</h4>
<p><code>new</code>命令的作用：<strong>执行构造函数，返回一个实例对象</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.price </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1000</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// this指向实例对象v</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> v </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// new 执行一个构造函数，返回一个实例对象给v</span></span>
<span class="line"><span style="color: #E1E4E8">v.price; </span><span style="color: #6A737D">// 1000</span></span></code></pre>
<p>上面代码通过<code>new</code>命令，让构造函数<code>Vehicle</code>生成一个实例对象，保存在变量<code>v</code>中。这个新生成的实例对象，从构造函数<code>Vehicle</code>得到了<code>price</code>属性。<code>new</code>命令执行时，构造函数内部的<code>this</code>，就代表了新生成的实例对象，<code>this.price</code>表示实例对象有一个<code>price</code>属性，值是 1000。</p>
<p>使用<code>new</code>命令时，根据需要，<strong>构造函数也可以接受参数</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">p</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.price </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> p;</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> v </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">500</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// new 命令时，构造函数可以接受参数</span></span></code></pre>
<p><code>new</code>命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也<strong>可以不带括号</strong>。下面两行代码是等价的，但是为了表示这里是函数调用，<strong>推荐使用括号</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 推荐的写法</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> v </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// 不推荐的写法</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> v </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8">();</span></span></code></pre>
<p>一个很自然的问题是，如果忘了使用<code>new</code>命令，直接调用构造函数会发生什么事？</p>
<p>这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，<code>this</code>这时代表全局对象，将造成一些意想不到的结果。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.price </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1000</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> v </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 忘记使用new命令，构造函数变成普通函数，不会生成实例，函数内部this指向window</span></span>
<span class="line"><span style="color: #E1E4E8">v; </span><span style="color: #6A737D">// undefined   函数为普通函数且没有返回值，所有v为undefined</span></span>
<span class="line"><span style="color: #E1E4E8">price; </span><span style="color: #6A737D">// 1000  函数内部this指向window， price变成全局属性，等价于window.price</span></span></code></pre>
<p>上面代码中，调用<code>Vehicle</code>构造函数时，忘了加上<code>new</code>命令。结果，变量<code>v</code>变成了<code>undefined</code>，而<code>price</code>属性变成了全局变量。因此，应该非常小心，避免不使用<code>new</code>命令、直接调用构造函数。</p>
<p>为了保证构造函数必须与<code>new</code>命令一起使用，一个解决办法是，<strong>构造函数内部使用严格模式</strong>，即第一行加上<code>use strict</code>。这样的话，一旦忘了使用<code>new</code>命令，直接调用构造函数就会报错。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Fubar</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">foo</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">bar</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #9ECBFF">"use strict"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">._foo </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> foo; </span><span style="color: #6A737D">// 严格模式中this不能指向window对象，不加new调用this等于undefined，给undefined添加属性会报错</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">._bar </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> bar;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #B392F0">Fubar</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// TypeError: Cannot set property '_foo' of undefined</span></span></code></pre>
<p>上面代码的<code>Fubar</code>为构造函数，<code>use strict</code>命令保证了该函数在严格模式下运行。由于<strong>严格模式中，函数内部的<code>this</code>不能指向全局对象</strong>，默认等于<code>undefined</code>，导致不加<code>new</code>调用会报错（JavaScript 不允许对<code>undefined</code>添加属性）。</p>
<p><strong>另一个解决办法</strong>，构造函数内部判断是否使用<code>new</code>命令，如果发现没有使用，则直接返回一个实例对象。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Fubar</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">foo</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">bar</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链（），返回布尔值。</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 语法： &#x3C;实例对象> instanceof &#x3C;构造函数></span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">!</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Fubar</span><span style="color: #E1E4E8">)) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">// 或 使用 (!new.target) 判断是否使用new命令</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Fubar</span><span style="color: #E1E4E8">(foo, bar);</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">._foo </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> foo;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">._bar </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> bar;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #B392F0">Fubar</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">_foo</span><span style="color: #E1E4E8">(</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 1</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Fubar</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">)._foo; </span><span style="color: #6A737D">// 1</span></span></code></pre>
<p>上面代码中的构造函数，不管加不加<code>new</code>命令，都会得到同样的结果。</p>
<h4 id="new-命令的原理">new 命令的原理</h4>
<p>使用<code>new</code>命令时，它后面的函数依次执行下面的步骤。</p>
<ol>
<li>
<p>创建一个空对象，作为将要返回的实例对象。</p>
</li>
<li>
<p>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</p>
</li>
<li>
<p>将这个空对象赋值给函数内部的<code>this</code>关键字。</p>
</li>
<li>
<p>开始执行构造函数内部的代码。（代码中 this 指向空对象（实例对象））</p>
</li>
<li>
<p>返回实例对象（或自定义对象）</p>
</li>
</ol>
<p>也就是说，构造函数内部，<code>this</code>指的是一个新生成的空对象，<strong>所有针对<code>this</code>的操作，都会发生在这个空对象上</strong>。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即<code>this</code>对象），将其“构造”为需要的样子。</p>
<p>如果构造函数内部有<code>return</code>语句，而且<code>return</code>后面跟着一个对象，<code>new</code>命令会返回<code>return</code>语句指定的对象；否则，就会不管<code>return</code>语句，返回<code>this</code>对象。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.price </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1000</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1000</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// 1000 非对象，被忽略，返回的是this对象；如果是return {}，则会返回{}</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8">() </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1000</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #6A737D">// false</span></span></code></pre>
<p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句返回一个数值。这时，<code>new</code>命令就会忽略这个<code>return</code>语句，返回“构造”后的<code>this</code>对象。</p>
<p>但是，如果<code>return</code>语句返回的是一个跟<code>this</code>无关的新对象，<code>new</code>命令会返回这个新对象，而不是<code>this</code>对象。这一点需要特别引起注意。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.price </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1000</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> { price: </span><span style="color: #79B8FF">2000</span><span style="color: #E1E4E8"> }; </span><span style="color: #6A737D">// return的是一个对象，会被返回出去。</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8">().price;</span></span>
<span class="line"><span style="color: #6A737D">// 2000</span></span></code></pre>
<p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句，返回的是一个新对象。<code>new</code>命令会返回这个对象，而不是<code>this</code>对象。</p>
<p>另一方面，如果对普通函数（内部没有<code>this</code>关键字的函数）使用<code>new</code>命令，则会返回一个空对象。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">getMessage</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 内部沒有this关键字，会返回一个空对象</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"this is a message"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> msg </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">getMessage</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">msg; </span><span style="color: #6A737D">// {}</span></span>
<span class="line"><span style="color: #F97583">typeof</span><span style="color: #E1E4E8"> msg; </span><span style="color: #6A737D">// "object"</span></span></code></pre>
<p>上面代码中，<code>getMessage</code>是一个普通函数，返回一个字符串。对它使用<code>new</code>命令，会得到一个空对象。这是因为**<code>new</code>命令总是返回一个对象，要么是实例对象，要么是<code>return</code>语句指定的对象**。本例中，<code>return</code>语句返回的是字符串，所以<code>new</code>命令就忽略了该语句。</p>
<p><code>new</code>命令简化的内部流程，可以用下面的代码表示。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 构造函数</span></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Person</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">name</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">age</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> name;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.age </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> age;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 自定义_new</span></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">_new</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 将 arguments 对象转为数组</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> args </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [].slice.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">arguments</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 取出构造函数</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> constructor </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> args.</span><span style="color: #B392F0">shift</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 创建一个空对象，继承构造函数的 prototype 属性</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> context </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 执行构造函数</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> result </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> constructor.</span><span style="color: #B392F0">apply</span><span style="color: #E1E4E8">(context, args);</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">typeof</span><span style="color: #E1E4E8"> result </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"object"</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">&#x26;&#x26;</span><span style="color: #E1E4E8"> result </span><span style="color: #F97583">!=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">?</span><span style="color: #E1E4E8"> result </span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> context;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 自定义_new2</span></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">_new2</span><span style="color: #E1E4E8">(</span><span style="color: #6A737D">/* 构造函数 */</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">constructor</span><span style="color: #E1E4E8">, </span><span style="color: #6A737D">/* 构造函数参数 */</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">params</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 创建一个空对象，继承构造函数的 prototype 属性</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> context </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 执行构造函数</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> result </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> constructor.</span><span style="color: #B392F0">apply</span><span style="color: #E1E4E8">(context, params);</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">typeof</span><span style="color: #E1E4E8"> result </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"object"</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">&#x26;&#x26;</span><span style="color: #E1E4E8"> result </span><span style="color: #F97583">!=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">?</span><span style="color: #E1E4E8"> result </span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> context;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// （当用户在构造函数内部自定义返回对象的话则使用该对象，否则返回context）</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 通过自定义_new 返回实例</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> actor </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">_new</span><span style="color: #E1E4E8">(Person, </span><span style="color: #9ECBFF">"张三"</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">28</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">actor.name; </span><span style="color: #6A737D">// 张三</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 通过自定义_new2 返回实例</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> actor2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">_new2</span><span style="color: #E1E4E8">(Person, [</span><span style="color: #9ECBFF">"李四"</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">29</span><span style="color: #E1E4E8">]);</span></span>
<span class="line"><span style="color: #E1E4E8">actor2.name; </span><span style="color: #6A737D">// 李四</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 通过new命令 返回实例</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> actor3 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Person</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"王五"</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">30</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">actor3.name; </span><span style="color: #6A737D">// 王五</span></span></code></pre>
<h4 id="newtarget-属性">new.target 属性</h4>
<p>构造函数内部可以使用<code>new.target</code>属性。如果当前函数是<code>new</code>命令调用，<code>new.target</code><strong>指向当前函数</strong>，否则为<code>undefined</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #F97583">new</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">target</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> f);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #B392F0">f</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// false</span></span>
<span class="line"><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// true</span></span></code></pre>
<p>使用这个属性，可以<strong>判断函数调用的时候，是否使用<code>new</code>命令</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">!new</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">target</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">throw</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Error</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"请使用 new 命令调用！"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// ...</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #B392F0">f</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// Uncaught Error: 请使用 new 命令调用！</span></span></code></pre>
<p>上面代码中，构造函数<code>f</code>调用时，没有使用<code>new</code>命令，就抛出一个错误。</p>
<h3 id="4objectcreate创建实例对象">4、Object.create()创建实例对象</h3>
<p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用<code>Object.create()</code>方法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 这个例子没有构造函数，只有一个对象</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> person1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 这个对象用来生成实例对象，它被当成一个模板</span></span>
<span class="line"><span style="color: #E1E4E8">  name: </span><span style="color: #9ECBFF">"张三"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  age: </span><span style="color: #79B8FF">38</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">greeting</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"Hi! I'm "</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"."</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> person2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(person1);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">person2.name; </span><span style="color: #6A737D">// 张三</span></span>
<span class="line"><span style="color: #E1E4E8">person2.</span><span style="color: #B392F0">greeting</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// Hi! I'm 张三.</span></span></code></pre>
<p>上面代码中，对象<code>person1</code>是<code>person2</code>的模板，后者继承了前者的属性和方法。</p>
<p><code>Object.create()</code>的详细介绍，请看后面的相关章节。</p>
<h2 id="二this-关键字">二、this 关键字</h2>
<h3 id="1涵义">1、涵义</h3>
<p><code>this</code>关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。</p>
<p>前一章已经提到，<code>this</code>可以用在构造函数之中，表示实例对象。除此之外，<code>this</code>还可以用在别的场合。但不管是什么场合，<code>this</code>都有一个共同点：<strong>它总是返回一个对象</strong>。</p>
<p>简单说，<strong><code>this</code>就是属性或方法“当前”所在的对象</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.property; </span><span style="color: #6A737D">// this代表property属性当前所在的对象</span></span></code></pre>
<p>上面代码中，<code>this</code>就代表<code>property</code>属性当前所在的对象。</p>
<p>下面是一个实际的例子。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> person </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  name: </span><span style="color: #9ECBFF">"张三"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">describe</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"姓名："</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name;</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">person.</span><span style="color: #B392F0">describe</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// "姓名：张三"</span></span></code></pre>
<p>上面代码中，<code>this.name</code>表示<code>name</code>属性所在的那个对象。由于<code>this.name</code>是在<code>describe</code>方法中调用，而<code>describe</code>方法所在的当前对象是<code>person</code>，因此<code>this</code>指向<code>person</code>，<code>this.name</code>就是<code>person.name</code>。</p>
<p>由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即<code>this</code><strong>的指向是可变的</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">A</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  name: </span><span style="color: #9ECBFF">"张三"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">describe</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"姓名："</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name;</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">B</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  name: </span><span style="color: #9ECBFF">"李四"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">B</span><span style="color: #E1E4E8">.describe </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">A</span><span style="color: #E1E4E8">.describe;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">/* 此时B的值：</span></span>
<span class="line"><span style="color: #6A737D">B={</span></span>
<span class="line"><span style="color: #6A737D"> name: '李四',</span></span>
<span class="line"><span style="color: #6A737D">    describe: function () {</span></span>
<span class="line"><span style="color: #6A737D">        return '姓名：'+ this.name;</span></span>
<span class="line"><span style="color: #6A737D">    }</span></span>
<span class="line"><span style="color: #6A737D">}</span></span>
<span class="line"><span style="color: #6A737D">*/</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">B</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">describe</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// B内部的this指向B对象</span></span>
<span class="line"><span style="color: #6A737D">// "姓名：李四"</span></span></code></pre>
<p>上面代码中，<code>A.describe</code>属性被赋给<code>B</code>，于是<code>B.describe</code>就表示<code>describe</code>方法所在的当前对象是<code>B</code>，所以<code>this.name</code>就指向<code>B.name</code>。</p>
<p>稍稍重构这个例子，<code>this</code>的动态指向就能看得更清楚。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'姓名：'</span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">A</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  name: </span><span style="color: #9ECBFF">'张三'</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  describe: f</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">B</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  name: </span><span style="color: #9ECBFF">'李四'</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  describe: f</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">A</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">describe</span><span style="color: #E1E4E8">() </span><span style="color: #6A737D">// "姓名：张三"</span></span>
<span class="line"><span style="color: #79B8FF">B</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">describe</span><span style="color: #E1E4E8">() </span><span style="color: #6A737D">// "姓名：李四"</span></span></code></pre>
<p>上面代码中，函数<code>f</code>内部使用了<code>this</code>关键字，随着<code>f</code>所在的对象不同，<code>this</code>的指向也不同。</p>
<p>只要函数被赋给另一个变量，<code>this</code>的指向就会变。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">A</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  name: </span><span style="color: #9ECBFF">"张三"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">describe</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"姓名："</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name;</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> name </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"李四"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> f </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">A</span><span style="color: #E1E4E8">.describe;</span></span>
<span class="line"><span style="color: #B392F0">f</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// "姓名：李四" f函数中的this和name变量所在的对象都为window顶层对象</span></span></code></pre>
<p>上面代码中，<code>A.describe</code>被赋值给变量<code>f</code>，内部的<code>this</code>就会指向<code>f</code>运行时所在的对象（本例是顶层对象）。</p>
<p>再看一个网页编程的例子。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">&#x3C;</span><span style="color: #85E89D">input</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">type</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"text"</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">name</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"age"</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">size</span><span style="color: #FDAEB7; font-style: italic">=3</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">onChange</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"validate(this, 18, 99);"</span><span style="color: #E1E4E8">></span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">&#x3C;</span><span style="color: #85E89D">script</span><span style="color: #E1E4E8">></span></span>
<span class="line"><span style="color: #E1E4E8">function validate(obj, lowval, hival){</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">if</span><span style="color: #E1E4E8"> ((obj.value </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> lowval) </span><span style="color: #F97583">||</span><span style="color: #E1E4E8"> (obj.value </span><span style="color: #F97583">></span><span style="color: #E1E4E8"> hival))</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'Invalid Value!'</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #E1E4E8">&#x3C;/</span><span style="color: #85E89D">script</span><span style="color: #E1E4E8">></span></span></code></pre>
<p>上面代码是一个文本输入框，每当用户输入一个值，就会调用<code>onChange</code>回调函数，验证这个值是否在指定范围。浏览器会向回调函数传入当前对象，因此<code>this</code>就代表传入当前对象（即文本框），然后就可以从<code>this.value</code>上面读到用户的输入值。</p>
<p>总结一下，<strong>JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，<code>this</code>就是函数运行时所在的对象（环境）</strong>。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，<code>this</code>的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。</p>
<h3 id="2实质">2、实质</h3>
<p>JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> { foo: </span><span style="color: #79B8FF">5</span><span style="color: #E1E4E8"> };</span></span></code></pre>
<p>上面的代码将一个对象赋值给变量<code>obj</code>。JavaScript 引擎会先在内存里面，生成一个对象<code>{ foo: 5 }</code>，然后把这个对象的内存地址赋值给变量<code>obj</code>。也就是说，变量<code>obj</code>是一个地址（reference）。后面如果要读取<code>obj.foo</code>，引擎先从<code>obj</code>拿到内存地址，然后再从该地址读出原始的对象，返回它的<code>foo</code>属性。</p>
<p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的<code>foo</code>属性，实际上是以下面的形式保存的。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">{</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">foo</span><span style="color: #E1E4E8">: {</span></span>
<span class="line"><span style="color: #E1E4E8">    [[value]]: </span><span style="color: #79B8FF">5</span></span>
<span class="line"><span style="color: #E1E4E8">    [[writable]]: </span><span style="color: #79B8FF">true</span></span>
<span class="line"><span style="color: #E1E4E8">    [[enumerable]]: </span><span style="color: #79B8FF">true</span></span>
<span class="line"><span style="color: #E1E4E8">    [[configurable]]: </span><span style="color: #79B8FF">true</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>注意，<code>foo</code>属性的值保存在属性描述对象的<code>value</code>属性里面。</p>
<p>这样的结构是很清晰的，问题在于属性的值可能是一个函数。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> { </span><span style="color: #B392F0">foo</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {} };</span></span></code></pre>
<p>这时，<strong>引擎会将函数单独保存在内存中</strong>，然后再将函数的地址赋值给<code>foo</code>属性的<code>value</code>属性。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">{</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">foo</span><span style="color: #E1E4E8">: {</span></span>
<span class="line"><span style="color: #E1E4E8">    [[value]]: 函数的地址</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">...</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {};</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> { f: f };</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 单独执行</span></span>
<span class="line"><span style="color: #B392F0">f</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// obj 环境执行</span></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">();</span></span></code></pre>
<p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(x);</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>上面代码中，函数体里面使用了变量<code>x</code>。该变量由运行环境提供。</p>
<p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，<strong>它的设计目的就是在函数体内部，指代函数当前的运行环境</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.x);</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>上面代码中，函数体里面的<code>this.x</code>就是指当前运行环境的<code>x</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.x);</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> x </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  f: f,</span></span>
<span class="line"><span style="color: #E1E4E8">  x: </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 单独执行</span></span>
<span class="line"><span style="color: #B392F0">f</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 1  f方法当前运行环境为window对象</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// obj 环境执行</span></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 2 f方法当前运行环境为obj对象</span></span></code></pre>
<p>上面代码中，函数<code>f</code>在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>；在<code>obj</code>环境执行，<code>this.x</code>指向<code>obj.x</code>。</p>
<h3 id="3使用场合">3、使用场合</h3>
<p><code>this</code>主要有以下几个使用场合。</p>
<h4 id="1全局环境">（1）全局环境</h4>
<p>全局环境使用<code>this</code>，它指的就是顶层对象<code>window</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #79B8FF">this</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> window; </span><span style="color: #6A737D">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> window);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #B392F0">f</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// true</span></span></code></pre>
<p>上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，<code>this</code>就是指顶层对象<code>window</code>。</p>
<h4 id="2构造函数-1">（2）构造函数</h4>
<p>构造函数中的<code>this</code>，指的是实例对象。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Obj</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">p</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.p </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> p; </span><span style="color: #6A737D">// this指向实例对象，在实例对象上定义属性p等于p值</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Obj</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"Hello World!"</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 通过new构造函数来声明实例对象o</span></span>
<span class="line"><span style="color: #E1E4E8">o.p; </span><span style="color: #6A737D">// "Hello World!"</span></span></code></pre>
<p>上面代码定义了一个构造函数<code>Obj</code>。由于<code>this</code>指向实例对象，所以在构造函数内部定义<code>this.p</code>，就相当于定义实例对象有一个<code>p</code>属性。</p>
<h4 id="3对象的方法">（3）对象的方法</h4>
<p>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变<code>this</code>的指向。</p>
<p>但是，这条规则很不容易把握。请看下面的代码。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">foo</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #B392F0">foo</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// obj</span></span></code></pre>
<p>上面代码中，<code>obj.foo</code>方法执行时，它内部的<code>this</code>指向<code>obj</code>。</p>
<p>但是，下面这几种用法，都会改变<code>this</code>的指向。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 情况一</span></span>
<span class="line"><span style="color: #E1E4E8">(obj.foo </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> obj.foo)()(</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// window</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 情况二</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">false</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">||</span><span style="color: #E1E4E8"> obj.foo</span></span>
<span class="line"><span style="color: #E1E4E8">)()(</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// window</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 情况三</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  obj.foo</span></span>
<span class="line"><span style="color: #E1E4E8">)(); </span><span style="color: #6A737D">// window</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">//obj.foo 是一个内存地址，它直接取出了 function () {console.log(this);} ，可以把obj.foo看做function () {console.log(this);}</span></span></code></pre>
<p>上面代码中，<code>obj.foo</code>就是一个值。这个值真正调用的时候，运行环境已经不是<code>obj</code>了，而是全局环境，所以<code>this</code>不再指向<code>obj</code>。</p>
<p>可以这样理解，JavaScript 引擎内部，<strong><code>obj</code>和<code>obj.foo</code>储存在两个内存地址</strong>，称为地址一和地址二。<code>obj.foo()</code>这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，<code>this</code>指向<code>obj</code>。但是，<strong>上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此<code>this</code>指向全局环境</strong>。上面三种情况等同于下面的代码。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">//obj.foo 是一个内存地址，它直接取出了 function () {console.log(this);} ，可以把obj.foo看做function () {console.log(this);}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 情况一</span></span>
<span class="line"><span style="color: #E1E4E8">(obj.</span><span style="color: #B392F0">foo</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">})()(</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 等同于</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">)()(</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 情况二</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">false</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">||</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">      console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"><span style="color: #E1E4E8">)()(</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 情况三</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">)();</span></span></code></pre>
<p>如果<code>this</code>所在的方法不在对象的第一层，这时<code>this</code>只是指向当前一层的对象，而不会继承更上面的层。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  p: </span><span style="color: #9ECBFF">"Hello"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  b: {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">m</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">      console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.p);</span></span>
<span class="line"><span style="color: #E1E4E8">    },</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">a.b.</span><span style="color: #B392F0">m</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// undefined</span></span></code></pre>
<p>上面代码中，<code>a.b.m</code>方法在<code>a</code>对象的第二层，该方法内部的<code>this</code>不是指向<code>a</code>，而是指向<code>a.b</code>，因为实际执行的是下面的代码。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> b </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">m</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.p);</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  p: </span><span style="color: #9ECBFF">"Hello"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  b: b,</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">a.b.</span><span style="color: #B392F0">m</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 等同于 b.m()</span></span></code></pre>
<p>如果要达到预期效果，只有写成下面这样。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  b: {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">m</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">      console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.p);</span></span>
<span class="line"><span style="color: #E1E4E8">    },</span></span>
<span class="line"><span style="color: #E1E4E8">    p: </span><span style="color: #9ECBFF">"Hello"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>如果这时将嵌套对象内部的方法赋值给一个变量，<code>this</code>依然会指向全局对象。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  b: {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">m</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">      console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.p);</span></span>
<span class="line"><span style="color: #E1E4E8">    },</span></span>
<span class="line"><span style="color: #E1E4E8">    p: </span><span style="color: #9ECBFF">"Hello"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> hello </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> a.b.m; </span><span style="color: #6A737D">// 把方法的内存地址赋值给了hello</span></span>
<span class="line"><span style="color: #B392F0">hello</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// undefined  内部this指向window</span></span></code></pre>
<p>上面代码中，<code>m</code>是多层对象内部的一个方法。为求简便，将其赋值给<code>hello</code>变量，结果调用时，<code>this</code>指向了顶层对象。为了避免这个问题，可以只将<code>m</code>所在的对象赋值给<code>hello</code>，这样调用时，<code>this</code>的指向就不会变。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> hello </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> a.b;</span></span>
<span class="line"><span style="color: #E1E4E8">hello.</span><span style="color: #B392F0">m</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// Hello   this指向不变</span></span></code></pre>
<h3 id="4使用注意点">4、使用注意点</h3>
<h4 id="1避免多层-this">（1）避免多层 this</h4>
<p>由于<code>this</code>的指向是不确定的，所以切勿在函数中包含多层的<code>this</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">f1</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// this指向o对象</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> f2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #6A737D">// 方法会另起一个内存地址</span></span>
<span class="line"><span style="color: #E1E4E8">      console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// this指向window对象</span></span>
<span class="line"><span style="color: #E1E4E8">    })();</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">o.</span><span style="color: #B392F0">f1</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// Object</span></span>
<span class="line"><span style="color: #6A737D">// Window</span></span></code></pre>
<p>上面代码包含两层<code>this</code>，结果运行后，第一层指向对象<code>o</code>，第二层指向全局对象，因为实际执行的是下面的代码。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">temp</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">f1</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> f2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">temp</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>一个解决方法是在第二层改用一个指向外层<code>this</code>的变量。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">f1</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> that </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// 使用变量保存this</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> f2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">      console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(that);</span></span>
<span class="line"><span style="color: #E1E4E8">    })();</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">o.</span><span style="color: #B392F0">f1</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// Object</span></span>
<span class="line"><span style="color: #6A737D">// Object</span></span></code></pre>
<p>上面代码定义了变量<code>that</code>，固定指向外层的<code>this</code>，然后在内层使用<code>that</code>，就不会发生<code>this</code>指向的改变。</p>
<p>事实上，使用一个变量固定<code>this</code>的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。</p>
<p>JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的<code>this</code>指向顶层对象，就会报错。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> counter </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  count: </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"><span style="color: #E1E4E8">counter.</span><span style="color: #B392F0">inc</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #9ECBFF">"use strict"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.count</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> f </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> counter.inc; </span><span style="color: #6A737D">// 这里直接取出方法的内存地址赋值给f，运行环境为window</span></span>
<span class="line"><span style="color: #B392F0">f</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// TypeError: Cannot read property 'count' of undefined</span></span></code></pre>
<p>上面代码中，<code>inc</code>方法通过<code>'use strict'</code>声明采用严格模式，这时内部的<code>this</code>一旦指向顶层对象，就会报错。</p>
<h4 id="2避免数组处理方法中的-this">（2）避免数组处理方法中的 this</h4>
<p>数组的<code>map</code>和<code>foreach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用<code>this</code> 。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  v: </span><span style="color: #9ECBFF">"hello"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  p: [</span><span style="color: #9ECBFF">"a1"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"a2"</span><span style="color: #E1E4E8">],</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.p.</span><span style="color: #B392F0">forEach</span><span style="color: #E1E4E8">(</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">item</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #6A737D">// 这个方法的运行环境为window</span></span>
<span class="line"><span style="color: #E1E4E8">      console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.v </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">" "</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> item);</span></span>
<span class="line"><span style="color: #E1E4E8">    });</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">o.</span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// undefined a1</span></span>
<span class="line"><span style="color: #6A737D">// undefined a2</span></span></code></pre>
<p>上面代码中，<code>foreach</code>方法的回调函数中的<code>this</code>，其实是指向<code>window</code>对象，因此取不到<code>o.v</code>的值。原因跟上一段的多层<code>this</code>是一样的，就是内层的<code>this</code>不指向外部，而指向顶层对象。</p>
<p>解决这个问题的一种方法，就是前面提到的，使用中间变量固定<code>this</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  v: </span><span style="color: #9ECBFF">"hello"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  p: [</span><span style="color: #9ECBFF">"a1"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"a2"</span><span style="color: #E1E4E8">],</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> that </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.p.</span><span style="color: #B392F0">forEach</span><span style="color: #E1E4E8">(</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">item</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">      console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(that.v </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">" "</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> item);</span></span>
<span class="line"><span style="color: #E1E4E8">    });</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">o.</span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// hello a1</span></span>
<span class="line"><span style="color: #6A737D">// hello a2</span></span></code></pre>
<p>另一种方法是将<code>this</code>当作<code>foreach</code>方法的第二个参数，固定它的运行环境。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  v: </span><span style="color: #9ECBFF">"hello"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  p: [</span><span style="color: #9ECBFF">"a1"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"a2"</span><span style="color: #E1E4E8">],</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.p.</span><span style="color: #B392F0">forEach</span><span style="color: #E1E4E8">(</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">item</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">      console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.v </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">" "</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> item);</span></span>
<span class="line"><span style="color: #E1E4E8">    }, </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">o.</span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// hello a1</span></span>
<span class="line"><span style="color: #6A737D">// hello a2</span></span></code></pre>
<p>ES6 箭头函数</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  v: </span><span style="color: #9ECBFF">"hello"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  p: [</span><span style="color: #9ECBFF">"a1"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"a2"</span><span style="color: #E1E4E8">],</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.p.</span><span style="color: #B392F0">forEach</span><span style="color: #E1E4E8">((</span><span style="color: #FFAB70">item</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #6A737D">// 箭头函数使this指向为o对象</span></span>
<span class="line"><span style="color: #E1E4E8">      console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.v </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">" "</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> item);</span></span>
<span class="line"><span style="color: #E1E4E8">    });</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">o.</span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// hello a1</span></span>
<span class="line"><span style="color: #6A737D">// hello a2</span></span></code></pre>
<h4 id="3避免回调函数中的-this">（3）避免回调函数中的 this</h4>
<p>回调函数中的<code>this</code>往往会改变指向，最好避免使用。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Object</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">o.</span><span style="color: #B392F0">f</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> o);</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// jQuery 的写法</span></span>
<span class="line"><span style="color: #B392F0">$</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"#button"</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">on</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"click"</span><span style="color: #E1E4E8">, o.f);</span></span></code></pre>
<p>上面代码中，点击按钮以后，控制台会显示<code>false</code>。原因是此时<code>this</code>不再指向<code>o</code>对象，而是指向按钮的 DOM 对象，因为<code>f</code>方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。</p>
<p>为了解决这个问题，可以采用下面的一些方法对<code>this</code>进行绑定，也就是使得<code>this</code>固定指向某个对象，减少不确定性。</p>
<h3 id="5绑定-this-的方法">5、绑定 this 的方法</h3>
<p><code>this</code>的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把<code>this</code>固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换/固定<code>this</code>的指向。</p>
<h4 id="functionprototypecall">Function.prototype.call()</h4>
<p>函数实例的<code>call</code>方法，可以<strong>指定函数内部<code>this</code>的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</strong></p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #B392F0">f</span><span style="color: #E1E4E8">() </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> window; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #E1E4E8">f.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(obj) </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> obj; </span><span style="color: #6A737D">// true 使函数内this指向obj，相当于把函数放入obj对象内运行。</span></span></code></pre>
<p>上面代码中，全局环境运行函数<code>f</code>时，<code>this</code>指向全局环境（浏览器为<code>window</code>对象）；<code>call</code>方法可以改变<code>this</code>的指向，指定<code>this</code>指向对象<code>obj</code>，然后在对象<code>obj</code>的作用域中运行函数<code>f</code>。</p>
<p><strong><code>call</code>方法的参数，应该是一个对象</strong>。如果参数为空、<code>null</code>和<code>undefined</code>，则<strong>默认传入全局对象</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> n </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">123</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> { n: </span><span style="color: #79B8FF">456</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">a</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.n);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 参数为空、null、undefined时默认传入全局对象</span></span>
<span class="line"><span style="color: #E1E4E8">a.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 123</span></span>
<span class="line"><span style="color: #E1E4E8">a.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 123</span></span>
<span class="line"><span style="color: #E1E4E8">a.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">undefined</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 123</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">a.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(window); </span><span style="color: #6A737D">// 123</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">a.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(obj); </span><span style="color: #6A737D">// 456</span></span></code></pre>
<p>上面代码中，<code>a</code>函数中的<code>this</code>关键字，如果指向全局对象，返回结果为<code>123</code>。如果使用<code>call</code>方法将<code>this</code>关键字指向<code>obj</code>对象，返回结果为<code>456</code>。可以看到，如果<code>call</code>方法没有参数，或者参数为<code>null</code>或<code>undefined</code>，则等同于指向全局对象。</p>
<p>如果<code>call</code>方法的参数是一个原始值，那么这个<strong>原始值会自动转成对应的包装对象</strong>，然后传入<code>call</code>方法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">f.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">5</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #6A737D">// Number {[[PrimitiveValue]]: 5} // Number的实例对象</span></span></code></pre>
<p>上面代码中，<code>call</code>的参数为<code>5</code>，不是对象，会被自动转成包装对象（<code>Number</code>的实例），绑定<code>f</code>内部的<code>this</code>。</p>
<p><code>call</code>方法还可以接受多个参数。</p>
<h5 id="语法">语法</h5>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">func.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(thisValue, arg1, arg2, </span><span style="color: #F97583">...</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #6A737D">// 第一个参数thisValue为函数内this将要指向的对象</span></span>
<span class="line"><span style="color: #6A737D">// 其余参数为传入函数的参数</span></span></code></pre>
<p><code>call</code>的第一个参数就是<code>this</code>所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">add</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">a</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">b</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> b;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">add.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 3</span></span></code></pre>
<p>上面代码中，<code>call</code>方法指定函数<code>add</code>内部的<code>this</code>绑定当前环境（对象），并且参数为<code>1</code>和<code>2</code>，因此函数<code>add</code>运行后得到<code>3</code>。</p>
<h5 id="应用调用对象的原生方法">应用：调用对象的原生方法</h5>
<p><code>call</code>方法的一个应用是调用对象的原生方法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {};</span></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #B392F0">hasOwnProperty</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'toString'</span><span style="color: #E1E4E8">) </span><span style="color: #6A737D">// false 判断obj是否有toString属性，注意这里不是toString()方法</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 覆盖掉继承的 hasOwnProperty 方法</span></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #B392F0">hasOwnProperty</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #B392F0">hasOwnProperty</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'toString'</span><span style="color: #E1E4E8">) </span><span style="color: #6A737D">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">Object</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.hasOwnProperty.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(obj, </span><span style="color: #9ECBFF">'toString'</span><span style="color: #E1E4E8">) </span><span style="color: #6A737D">// false</span></span></code></pre>
<p>上面代码中，<code>hasOwnProperty</code>是<code>obj</code>对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。<code>call</code>方法可以解决这个问题，它将<code>hasOwnProperty</code>方法的原始定义放到<code>obj</code>对象上执行，这样无论<code>obj</code>上有没有同名方法，都不会影响结果。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> objArr </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 类数组对象</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">: </span><span style="color: #9ECBFF">"c"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  length: </span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> arr </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">Array</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.slice.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(objArr); </span><span style="color: #6A737D">// 执行数组的slice方法，并把obj指定为方法的this</span></span>
<span class="line"><span style="color: #6A737D">// 或 arr = [].slice.call(obj)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">arr; </span><span style="color: #6A737D">// ['a','b','c']</span></span></code></pre>
<p>上面代码中，<code>objArr</code>是一个类似数组的对象，使用<code>call</code>调用数组的<code>slice</code>方法，指定<code>objArr</code>为<code>slice</code>方法内部的<code>this</code>，<code>slice</code>方法返回值赋给<code>arr</code>。</p>
<p>另外来看看数组<code>slice</code>方法的内部实现原理</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #79B8FF">Array</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">slice</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">start</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">end</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">//数组方法slice的底层内部实现</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> result </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Array</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">//新数组</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> start </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> start </span><span style="color: #F97583">||</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> end </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> end </span><span style="color: #F97583">||</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">length</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">//this指向调用的对象，用了call之后，改变this的指向，指向传进来的对象</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> i </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> start; i </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> end; i</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    result.</span><span style="color: #B392F0">push</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">[i]);</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> result; </span><span style="color: #6A737D">//返回的为一个新的数组</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<h4 id="functionprototypeapply">Function.prototype.apply()</h4>
<p><code>apply</code>方法的作用与<code>call</code>方法类似，也是改变<code>this</code>指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p>
<h5 id="语法-1">语法</h5>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">func.</span><span style="color: #B392F0">apply</span><span style="color: #E1E4E8">(thisValue, [arg1, arg2, </span><span style="color: #F97583">...</span><span style="color: #E1E4E8">])</span></span>
<span class="line"><span style="color: #6A737D">// 第一个参数thisValue为函数内this将要指向的对象</span></span>
<span class="line"><span style="color: #6A737D">// 第二个参数为一个数组，数组每一项为传入函数的参数</span></span></code></pre>
<p><code>apply</code>方法的第一个参数也是<code>this</code>所要指向的那个对象，如果设为<code>null</code>或<code>undefined</code>，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在<code>call</code>方法中必须一个个添加，但是在<code>apply</code>方法中，必须以数组形式添加。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">x</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">y</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(x </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> y);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">f.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 2</span></span>
<span class="line"><span style="color: #E1E4E8">f.</span><span style="color: #B392F0">apply</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">, [</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">]); </span><span style="color: #6A737D">// 2</span></span></code></pre>
<p>上面代码中，<code>f</code>函数本来接受两个参数，使用<code>apply</code>方法以后，就变成可以接受一个数组作为参数。</p>
<p>利用这一点，可以做一些有趣的应用。</p>
<h5 id="应用">应用</h5>
<h5 id="1获取数组最大最小元素">（1）获取数组最大/最小元素</h5>
<p>JavaScript 不提供找出数组最大元素的函数。结合使用<code>apply</code>方法和<code>Math.max/Math.min</code>方法，就可以返回数组的最大/最小元素。</p>
<p><strong>利用第二个参数为数组的特点</strong></p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 获取最大值</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [</span><span style="color: #79B8FF">10</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">4</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">15</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">9</span><span style="color: #E1E4E8">];</span></span>
<span class="line"><span style="color: #E1E4E8">Math.max.</span><span style="color: #B392F0">apply</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">, a); </span><span style="color: #6A737D">// 15</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">//Math.max方法获取最大值</span></span>
<span class="line"><span style="color: #6A737D">//Math.max(10, 2, 4, 15, 9) // 15</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 获取最小值</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [</span><span style="color: #79B8FF">10</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">4</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">15</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">9</span><span style="color: #E1E4E8">];</span></span>
<span class="line"><span style="color: #E1E4E8">Math.min.</span><span style="color: #B392F0">apply</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">, a); </span><span style="color: #6A737D">// 15    null等于绑定全局对象</span></span></code></pre>
<h5 id="2将数组的空元素变为undefined">（2）将数组的空元素变为<code>undefined</code></h5>
<p>通过<code>apply</code>方法，利用<code>Array</code>构造函数将数组的空元素变成<code>undefined</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">Array.</span><span style="color: #B392F0">apply</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">, [</span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">, , </span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8">]);</span></span>
<span class="line"><span style="color: #6A737D">// [ 'a', undefined, 'b' ]</span></span></code></pre>
<p>空元素与<code>undefined</code>的差别在于，数组的<code>forEach</code>方法会跳过空元素，但是不会跳过<code>undefined</code>。因此，遍历内部元素的时候，会得到不同的结果。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [</span><span style="color: #9ECBFF">"a"</span><span style="color: #E1E4E8">, , </span><span style="color: #9ECBFF">"b"</span><span style="color: #E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">print</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">i</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(i);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">a.</span><span style="color: #B392F0">forEach</span><span style="color: #E1E4E8">(print);</span></span>
<span class="line"><span style="color: #6A737D">// a</span></span>
<span class="line"><span style="color: #6A737D">// b</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">Array.</span><span style="color: #B392F0">apply</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">, a).</span><span style="color: #B392F0">forEach</span><span style="color: #E1E4E8">(print);</span></span>
<span class="line"><span style="color: #6A737D">// a</span></span>
<span class="line"><span style="color: #6A737D">// undefined</span></span>
<span class="line"><span style="color: #6A737D">// b</span></span></code></pre>
<h5 id="3转换类似数组的对象">（3）转换类似数组的对象</h5>
<p>另外，利用数组对象的<code>slice</code>方法，可以将一个类似数组的对象（比如<code>arguments</code>对象）转为真正的数组。</p>
<p>和使用<code>call</code>方法的效果一样。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #79B8FF">Array</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.slice.</span><span style="color: #B392F0">apply</span><span style="color: #E1E4E8">({ </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">: </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, length: </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8"> }); </span><span style="color: #6A737D">// [1]</span></span>
<span class="line"><span style="color: #79B8FF">Array</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.slice.</span><span style="color: #B392F0">apply</span><span style="color: #E1E4E8">({ </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">: </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8"> }); </span><span style="color: #6A737D">// []</span></span>
<span class="line"><span style="color: #79B8FF">Array</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.slice.</span><span style="color: #B392F0">apply</span><span style="color: #E1E4E8">({ </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">: </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, length: </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8"> }); </span><span style="color: #6A737D">// [1, undefined]</span></span>
<span class="line"><span style="color: #79B8FF">Array</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.slice.</span><span style="color: #B392F0">apply</span><span style="color: #E1E4E8">({ length: </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8"> }); </span><span style="color: #6A737D">// [undefined]</span></span></code></pre>
<p>上面代码的<code>apply</code>方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有<code>length</code>属性，以及相对应的数字键。</p>
<h5 id="4绑定回调函数的对象">（4）绑定回调函数的对象</h5>
<p>前面的按钮点击事件的例子，可以改写如下。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Object</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">o.</span><span style="color: #B392F0">f</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> o); </span><span style="color: #6A737D">// true  ，如未改变this指向，this将指向 DOM 对象</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  o.f.</span><span style="color: #B392F0">apply</span><span style="color: #E1E4E8">(o);</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 或者 o.f.call(o);</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// jQuery 的写法</span></span>
<span class="line"><span style="color: #B392F0">$</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"#button"</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">on</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"click"</span><span style="color: #E1E4E8">, f);</span></span></code></pre>
<p>上面代码中，点击按钮以后，控制台将会显示<code>true</code>。由于<code>apply</code>方法（或者<code>call</code>方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的<code>bind</code>方法。</p>
<h4 id="functionprototypebind">Function.prototype.bind()</h4>
<p><code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后<strong>返回一个新函数，bind 方法并非立即执行一个函数。</strong></p>
<h5 id="语法-2">语法</h5>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">func.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(thisValue, arg1, arg2, </span><span style="color: #F97583">...</span><span style="color: #E1E4E8">)()</span></span>
<span class="line"><span style="color: #6A737D">// 第一个参数thisValue为函数内this将要指向的对象</span></span>
<span class="line"><span style="color: #6A737D">// 其余参数为传入函数的参数</span></span>
<span class="line"><span style="color: #6A737D">// bind方法返回一个新函数，并非立即执行，如需执行要在后面加个括号</span></span></code></pre>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> d </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Date</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">d.</span><span style="color: #B392F0">getTime</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 1481869925657</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> print </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> d.getTime;</span></span>
<span class="line"><span style="color: #B392F0">print</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// Uncaught TypeError: this is not a Date object.</span></span></code></pre>
<p>上面代码中，我们将<code>d.getTime</code>方法赋给变量<code>print</code>，然后调用<code>print</code>就报错了。这是因为<code>getTime</code>方法内部的<code>this</code>，绑定<code>Date</code>对象的实例，赋给变量<code>print</code>以后，内部的<code>this</code>已经不指向<code>Date</code>对象的实例了。</p>
<p><code>bind</code>方法可以解决这个问题。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> print </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> d.getTime.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(d);</span></span>
<span class="line"><span style="color: #B392F0">print</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 1481869925657</span></span></code></pre>
<p>上面代码中，<code>bind</code>方法将<code>getTime</code>方法内部的<code>this</code>绑定到<code>d</code>对象，这时就可以安全地将这个方法赋值给其他变量了。</p>
<p><code>bind</code>方法的参数就是所要绑定<code>this</code>的对象，下面是一个更清晰的例子。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> counter </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  count: </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">inc</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.count</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> func </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> counter.inc.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(counter);</span></span>
<span class="line"><span style="color: #B392F0">func</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">counter.count; </span><span style="color: #6A737D">// 1</span></span></code></pre>
<p>上面代码中，<code>counter.inc</code>方法被赋值给变量<code>func</code>。这时必须用<code>bind</code>方法将<code>inc</code>内部的<code>this</code>，绑定到<code>counter</code>，否则就会出错。</p>
<p><code>this</code>绑定到其他对象也是可以的。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> counter </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  count: </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">inc</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.count</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  count: </span><span style="color: #79B8FF">100</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> func </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> counter.inc.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(obj);</span></span>
<span class="line"><span style="color: #B392F0">func</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">obj.count; </span><span style="color: #6A737D">// 101</span></span></code></pre>
<p>上面代码中，<code>bind</code>方法将<code>inc</code>方法内部的<code>this</code>，绑定到<code>obj</code>对象。结果调用<code>func</code>函数以后，递增的就是<code>obj</code>内部的<code>count</code>属性。</p>
<p><code>bind</code>还可以接受更多的参数，将这些参数绑定原函数的参数。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">add</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">x</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">y</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> x </span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.m </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> y </span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.n;</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  m: </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  n: </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> newAdd </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> add.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(obj, </span><span style="color: #79B8FF">5</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 第二个参数为add内的x</span></span>
<span class="line"><span style="color: #B392F0">newAdd</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">5</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 20 传入的参数为add内的y</span></span></code></pre>
<p>上面代码中，<code>bind</code>方法除了绑定<code>this</code>对象，还将<code>add</code>函数的第一个参数<code>x</code>绑定成<code>5</code>，然后返回一个新函数<code>newAdd</code>，这个函数只要再接受一个参数<code>y</code>就能运行了。</p>
<p>如果<code>bind</code>方法的第一个参数是<code>null</code>或<code>undefined</code>，等于将<code>this</code>绑定到全局对象，函数运行时<code>this</code>指向顶层对象（浏览器为<code>window</code>）。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">add</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">x</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">y</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> x </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> y;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> plus5 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> add.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">5</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #B392F0">plus5</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">10</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 15  传入的参数为add内的y</span></span></code></pre>
<p>上面代码中，函数<code>add</code>内部并没有<code>this</code>，使用<code>bind</code>方法的主要目的是绑定参数<code>x</code>，以后每次运行新函数<code>plus5</code>，就只需要提供另一个参数<code>y</code>就够了。而且因为<code>add</code>内部没有<code>this</code>，所以<code>bind</code>的第一个参数是<code>null</code>，不过这里如果是其他对象，也没有影响。</p>
<h5 id="bind-要注意的点">bind 要注意的点</h5>
<h5 id="1每一次返回一个新函数">（1）每一次返回一个新函数</h5>
<p><code>bind</code>方法<strong>每运行一次，就返回一个新函数</strong>，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">element.</span><span style="color: #B392F0">addEventListener</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"click"</span><span style="color: #E1E4E8">, o.m.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(o));</span></span></code></pre>
<p>上面代码中，<code>click</code>事件绑定<code>bind</code>方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">element.</span><span style="color: #B392F0">removeEventListener</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"click"</span><span style="color: #E1E4E8">, o.m.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(o));</span></span></code></pre>
<p>正确的方法是写成下面这样：</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> listener </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> o.m.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(o);</span></span>
<span class="line"><span style="color: #E1E4E8">element.</span><span style="color: #B392F0">addEventListener</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"click"</span><span style="color: #E1E4E8">, listener);</span></span>
<span class="line"><span style="color: #6A737D">//  ...</span></span>
<span class="line"><span style="color: #E1E4E8">element.</span><span style="color: #B392F0">removeEventListener</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"click"</span><span style="color: #E1E4E8">, listener);</span></span></code></pre>
<h5 id="2结合回调函数使用">（2）结合回调函数使用</h5>
<p>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含<code>this</code>的方法直接当作回调函数。解决方法就是使用<code>bind</code>方法，将<code>counter.inc</code>绑定<code>counter</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> counter </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  count: </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">inc</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #9ECBFF">"use strict"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.count</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">callIt</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">callback</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">callback</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #B392F0">callIt</span><span style="color: #E1E4E8">(counter.inc.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(counter));</span></span>
<span class="line"><span style="color: #E1E4E8">counter.count; </span><span style="color: #6A737D">// 1</span></span></code></pre>
<p>上面代码中，<code>callIt</code>方法会调用回调函数。这时如果直接把<code>counter.inc</code>传入，调用时<code>counter.inc</code>内部的<code>this</code>就会指向全局对象。使用<code>bind</code>方法将<code>counter.inc</code>绑定<code>counter</code>以后，就不会有这个问题，<code>this</code>总是指向<code>counter</code>。</p>
<p>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的<code>this</code>指向，很可能也会出错。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  name: </span><span style="color: #9ECBFF">"张三"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  times: [</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">],</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">print</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.times.</span><span style="color: #B392F0">forEach</span><span style="color: #E1E4E8">(</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">n</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #6A737D">// 数组的forEach方法内部this指向问题</span></span>
<span class="line"><span style="color: #E1E4E8">      console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name); </span><span style="color: #6A737D">// 这里的this指向全局对象</span></span>
<span class="line"><span style="color: #E1E4E8">    });</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #B392F0">print</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// 没有任何输出</span></span></code></pre>
<p>上面代码中，<code>obj.print</code>内部<code>this.times</code>的<code>this</code>是指向<code>obj</code>的，这个没有问题。但是，<code>forEach</code>方法的回调函数内部的<code>this.name</code>却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #B392F0">print</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.times.</span><span style="color: #B392F0">forEach</span><span style="color: #E1E4E8">(</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">n</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> window);</span></span>
<span class="line"><span style="color: #E1E4E8">  });</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #B392F0">print</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #6A737D">// true</span></span></code></pre>
<p>解决这个问题，也是通过<code>bind</code>方法绑定<code>this</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #B392F0">print</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.times.</span><span style="color: #B392F0">forEach</span><span style="color: #E1E4E8">(</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">n</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">      console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name);</span></span>
<span class="line"><span style="color: #E1E4E8">    }.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">  ); </span><span style="color: #6A737D">// 使用bind把this指向的obj对象传入方法内</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #B392F0">print</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// 张三</span></span>
<span class="line"><span style="color: #6A737D">// 张三</span></span>
<span class="line"><span style="color: #6A737D">// 张三</span></span></code></pre>
<h5 id="3结合call方法使用改写数组方法调用形式">（3）结合<code>call</code>方法使用（改写数组方法调用形式）</h5>
<p>利用<code>bind</code>方法，可以<strong>改写一些 JavaScript 原生方法的使用形式</strong>，以数组的<code>slice</code>方法为例。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">[</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">].</span><span style="color: #B392F0">slice</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// [1]</span></span>
<span class="line"><span style="color: #6A737D">// 等同于</span></span>
<span class="line"><span style="color: #79B8FF">Array</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.slice.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">([</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">], </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// [1]</span></span></code></pre>
<p>上面的代码中，数组的<code>slice</code>方法从<code>[1, 2, 3]</code>里面，按照指定位置和长度切分出另一个数组。这样做的本质是在<code>[1, 2, 3]</code>上面调用<code>Array.prototype.slice</code>方法，因此可以用<code>call</code>方法表达这个过程，得到同样的结果。</p>
<p><code>call</code>方法实质上是调用<code>Function.prototype.call</code>方法，因此上面的表达式可以<strong>用<code>bind</code>方法改写</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> slice </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">Function</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.call.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">Array</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.slice);</span></span>
<span class="line"><span style="color: #B392F0">slice</span><span style="color: #E1E4E8">([</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">], </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// [1]</span></span></code></pre>
<p>上面代码的含义就是，将<code>Array.prototype.slice</code>变成<code>Function.prototype.call</code>方法所在的对象，调用时就变成了<code>Array.prototype.slice.call</code>。类似的写法还可以用于其他数组方法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> push </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">Function</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.call.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">Array</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.push);</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> pop </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">Function</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.call.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">Array</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.pop);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">];</span></span>
<span class="line"><span style="color: #B392F0">push</span><span style="color: #E1E4E8">(a, </span><span style="color: #79B8FF">4</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">a; </span><span style="color: #6A737D">// [1, 2, 3, 4]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #B392F0">pop</span><span style="color: #E1E4E8">(a);</span></span>
<span class="line"><span style="color: #E1E4E8">a; </span><span style="color: #6A737D">// [1, 2, 3]</span></span></code></pre>
<p>如果再进一步，将<code>Function.prototype.call</code>方法绑定到<code>Function.prototype.bind</code>对象，就意味着<code>bind</code>的调用形式也可以被改写。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.v);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> { v: </span><span style="color: #79B8FF">123</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> bind </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">Function</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.call.</span><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">Function</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.bind);</span></span>
<span class="line"><span style="color: #B392F0">bind</span><span style="color: #E1E4E8">(f, o)(); </span><span style="color: #6A737D">// 123</span></span></code></pre>
<p>上面代码的含义就是，将<code>Function.prototype.bind</code>方法绑定在<code>Function.prototype.call</code>上面，所以<code>bind</code>方法就可以直接使用，不需要在函数实例上使用。</p>
<h4 id="总结callapplybind的区别">总结，call()、apply()、bind()的区别</h4>
<p>这三个方法都是改变函数内部 this 指向的。</p>
<p>它们的区别是：</p>
<p>call()第一个参数为函数内 this 将要指向的对象，其余参数为传入函数的参数。</p>
<p>apply()第一个参数为函数内 this 将要指向的对象，第二个参数为数组，数组每一项为传入函数的参数。</p>
<p>bind()传入参数和 call()一样，区别是 bind()返回一个新的函数，并非立即执行。</p>
<h2 id="三对象的继承">三、对象的继承</h2>
<p>面向对象编程很重要的一个方面，就是对象的继承。<strong>A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的</strong>。</p>
<p>大部分面向对象的编程语言，都是通过“类”（class）实现对象的继承。传统上，JavaScript 语言的继承不通过 class，而是通过“原型对象”（prototype）实现，本章介绍 JavaScript 的原型链继承。</p>
<p>ES6 引入了 class 语法，基于 class 的继承不在这个教程介绍，请参阅《ES6 标准入门》一书的相关章节。</p>
<p><strong>ES5 是通过“原型对象”（prototype）实现继承。</strong></p>
<h3 id="1原型对象概述">1、原型对象概述</h3>
<h4 id="1构造函数的缺点">（1）构造函数的缺点</h4>
<p>JavaScript 通过构造函数生成新对象，因此<strong>构造函数可以视为对象的模板</strong>。实例对象的属性和方法，可以定义在构造函数内部。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Cat</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">name</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">color</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> name;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.color </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> color;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> cat1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Cat</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"大毛"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"白色"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">cat1.name; </span><span style="color: #6A737D">// '大毛'</span></span>
<span class="line"><span style="color: #E1E4E8">cat1.color; </span><span style="color: #6A737D">// '白色'</span></span></code></pre>
<p>上面代码中，<code>Cat</code>函数是一个构造函数，函数内部定义了<code>name</code>属性和<code>color</code>属性，所有实例对象（上例是<code>cat1</code>）都会生成这两个属性，即这两个属性会定义在实例对象上面。</p>
<p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。<strong>同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Cat</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">name</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">color</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> name;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.color </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> color;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">meow</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"喵喵"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 解决方法，就是在原型对象（prototype）上创建共同的方法</span></span>
<span class="line"><span style="color: #79B8FF">Cat</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">meow2</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"喵喵"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> cat1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Cat</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"大毛"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"白色"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> cat2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Cat</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"二毛"</span><span style="color: #E1E4E8">, </span><span style="color: #9ECBFF">"黑色"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// cat1和cat2是同一个构造函数的两个实例对象，他们无法共享meow属性，从而造成对系统资源的浪费。</span></span>
<span class="line"><span style="color: #E1E4E8">cat1.meow </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> cat2.meow;</span></span>
<span class="line"><span style="color: #6A737D">// false</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">cat1.meow2 </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> cat2.meow2;</span></span>
<span class="line"><span style="color: #6A737D">// true</span></span></code></pre>
<p>上面代码中，<code>cat1</code>和<code>cat2</code>是同一个构造函数的两个实例，它们都具有<code>meow</code>方法。由于<code>meow</code>方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个<code>meow</code>方法。这既没有必要，又浪费系统资源，因为所有<code>meow</code>方法都是同样的行为，完全应该共享。</p>
<p><strong>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</strong></p>
<h4 id="2prototype-属性的作用">（2）prototype 属性的作用</h4>
<p><strong>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享</strong>。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p>
<p>下面，先看怎么为对象指定原型。JavaScript 规定，<strong>每个函数都有一个<code>prototype</code>属性，指向一个对象</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">() {}</span></span>
<span class="line"><span style="color: #F97583">typeof</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">f</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// "object"</span></span></code></pre>
<p>上面代码中，函数<code>f</code>默认具有<code>prototype</code>属性，指向一个对象。</p>
<p><strong>对于普通函数来说，该属性基本无用</strong>。但是，<strong>对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Animal</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">name</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> name;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #6A737D">// Animal.prototype属性是实例cat1和cat2的原型对象，在上面添加属性，实例就共享了该属性</span></span>
<span class="line"><span style="color: #79B8FF">Animal</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.color </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"white"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> cat1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Animal</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"大毛"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> cat2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Animal</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"二毛"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">cat1.color; </span><span style="color: #6A737D">// 'white'</span></span>
<span class="line"><span style="color: #E1E4E8">cat2.color; </span><span style="color: #6A737D">// 'white'</span></span></code></pre>
<p>上面代码中，构造函数<code>Animal</code>的<code>prototype</code>属性，就是实例对象<code>cat1</code>和<code>cat2</code>的原型对象。原型对象上添加一个<code>color</code>属性，结果，实例对象都共享了该属性。</p>
<p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在<strong>所有</strong>实例对象上。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #79B8FF">Animal</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.color </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"yellow"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// color属性并非实例对象cat1/cat2本身的属性,只是当实例本身没有该属性或方法时，它会到原型对象去寻找该属性或方法</span></span>
<span class="line"><span style="color: #E1E4E8">cat1.color; </span><span style="color: #6A737D">// "yellow"</span></span>
<span class="line"><span style="color: #E1E4E8">cat2.color; </span><span style="color: #6A737D">// "yellow"</span></span></code></pre>
<p>上面代码中，原型对象的<code>color</code>属性的值变为<code>yellow</code>，两个实例对象的<code>color</code>属性立刻跟着变了。这是因为实例对象其实没有<code>color</code>属性，都是读取原型对象的<code>color</code>属性。也就是说，**当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。**这就是原型对象的特殊之处。</p>
<p>如果<strong>实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">cat1.color </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"black"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">cat1.color; </span><span style="color: #6A737D">// 'black'</span></span>
<span class="line"><span style="color: #E1E4E8">cat2.color; </span><span style="color: #6A737D">// 'yellow'</span></span>
<span class="line"><span style="color: #79B8FF">Animal</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.color; </span><span style="color: #6A737D">// 'yellow';</span></span></code></pre>
<p>上面代码中，实例对象<code>cat1</code>的<code>color</code>属性改为<code>black</code>，就使得它不再去原型对象读取<code>color</code>属性，后者的值依然为<code>yellow</code>。</p>
<p>总结一下，原型对象的<strong>作用</strong>，<strong>就是定义所有实例对象共享的属性和方法</strong>。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #79B8FF">Animal</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">walk</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">" is walking"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>上面代码中，<code>Animal.prototype</code>对象上面定义了一个<code>walk</code>方法，这个方法将可以在所有<code>Animal</code>实例对象上面调用。</p>
<h4 id="3原型链">（3）原型链</h4>
<p><strong>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</strong></p>
<p>如果一层层地上溯，所有对象的原型<strong>最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性</strong>。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p>
<p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，<strong>原型链的尽头就是<code>null</code></strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">getPrototypeOf</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">Object</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// Object.getPrototypeOf方法返回对象的原型</span></span>
<span class="line"><span style="color: #6A737D">// null</span></span></code></pre>
<p>上面代码表示，<code>Object.prototype</code>对象的原型是<code>null</code>，由于<code>null</code>没有任何属性，所以原型链到此为止。<code>Object.getPrototypeOf</code>方法返回参数对象的原型，具体介绍请看后文。</p>
<p><strong>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code></strong>。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p>
<p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p>
<p>举例来说，如果让构造函数的<code>prototype</code>属性指向一个数组，就意味着实例对象可以调用数组方法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">MyArray</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">MyArray</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Array</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 构造函数MyArray的原型指向 数组实例</span></span>
<span class="line"><span style="color: #79B8FF">MyArray</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> MyArray;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> mine </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">MyArray</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// mine是构造函数MyArray的实例</span></span>
<span class="line"><span style="color: #E1E4E8">mine.</span><span style="color: #B392F0">push</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">mine.</span><span style="color: #79B8FF">length</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// 3</span></span>
<span class="line"><span style="color: #E1E4E8">mine </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Array</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true 判断实例对象mine是否为构造函数Array的实例</span></span></code></pre>
<p>上面代码中，<code>mine</code>是构造函数<code>MyArray</code>的实例对象，由于<code>MyArray.prototype</code>指向一个数组实例，使得<code>mine</code>可以调用数组方法（这些方法定义在数组实例的<code>prototype</code>对象上面）。最后那行<code>instanceof</code>表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明<code>mine</code>为<code>Array</code>的实例，<code>instanceof</code>运算符的详细解释详见后文。</p>
<p>上面代码还出现了原型对象的<code>constructor</code>属性，这个属性的含义下一节就来解释。</p>
<h4 id="4constructor-属性">（4）constructor 属性</h4>
<p><strong><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。</strong></p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">P</span><span style="color: #E1E4E8">() {}</span></span>
<span class="line"><span style="color: #79B8FF">P</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">P</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span></code></pre>
<p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">P</span><span style="color: #E1E4E8">() {}</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> p </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">P</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">p.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">P</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true  p自身没有constructor属性，它是读取原型上的</span></span>
<span class="line"><span style="color: #E1E4E8">p.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">P</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #E1E4E8">p.</span><span style="color: #B392F0">hasOwnProperty</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"constructor"</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// false</span></span></code></pre>
<p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性。</p>
<h5 id="作用">作用</h5>
<p><code>constructor</code>属性的<strong>作用</strong>是，<strong>可以得知某个实例对象，到底是哪一个构造函数产生的</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">F</span><span style="color: #E1E4E8">() {}</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> f </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">F</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">f.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">F</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #E1E4E8">f.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> RegExp; </span><span style="color: #6A737D">// false</span></span></code></pre>
<p>上面代码中，<code>constructor</code>属性确定了实例对象<code>f</code>的构造函数是<code>F</code>，而不是<code>RegExp</code>。</p>
<p>另一方面，有了<code>constructor</code>属性，就可以从一个实例对象新建另一个实例。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Constr</span><span style="color: #E1E4E8">() {}</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> x </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Constr</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> y </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> x.</span><span style="color: #B392F0">constructor</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 等同于 new Constr()</span></span>
<span class="line"><span style="color: #E1E4E8">y </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Constr</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span></code></pre>
<p>上面代码中，<code>x</code>是构造函数<code>Constr</code>的实例，可以从<code>x.constructor</code>间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #79B8FF">Constr</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">createCopy</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">constructor</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>上面代码中，<code>createCopy</code>方法调用构造函数，新建另一个实例。</p>
<p><code>constructor</code>属性<strong>表示原型对象与构造函数之间的关联关系</strong>，如果修改了原型对象，一般会同时修改<code>constructor</code>属性，防止引用的时候出错。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Person</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">name</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> name;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">Person</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> Person; </span><span style="color: #6A737D">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">Person</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 修改了原型对象,但没有修改原型下的constructor</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">method</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {},</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">//  由于原型对象已被修改，原型下的constructor也被修改</span></span>
<span class="line"><span style="color: #79B8FF">Person</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> Person; </span><span style="color: #6A737D">// false</span></span>
<span class="line"><span style="color: #79B8FF">Person</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> Object; </span><span style="color: #6A737D">// true // 普通对象的constructor指向object构造函数</span></span></code></pre>
<p>上面代码中，构造函数<code>Person</code>的原型对象改掉了，但是没有修改<code>constructor</code>属性，导致这个属性不再指向<code>Person</code>。由于<code>Person</code>的新原型是一个普通对象，而普通对象的<code>constructor</code>属性指向<code>Object</code>构造函数，导致<code>Person.prototype.constructor</code>变成了<code>Object</code>。</p>
<p>所以，修改原型对象时，一般要同时修改<code>constructor</code>属性的指向。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 坏的写法</span></span>
<span class="line"><span style="color: #79B8FF">C</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">method1</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (...) { </span><span style="color: #F97583">...</span><span style="color: #E1E4E8"> },</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// ...</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 好的写法</span></span>
<span class="line"><span style="color: #79B8FF">C</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  constructor: </span><span style="color: #79B8FF">C</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">method1</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (...) { </span><span style="color: #F97583">...</span><span style="color: #E1E4E8"> },</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// ...</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 更好的写法 （只是在原型对象上添加方法）</span></span>
<span class="line"><span style="color: #79B8FF">C</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">method1</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (...) { </span><span style="color: #F97583">...</span><span style="color: #E1E4E8"> };</span></span></code></pre>
<p>上面代码中，要么将<code>constructor</code>属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证<code>instanceof</code>运算符不会失真。</p>
<p>如果不能确定<code>constructor</code>属性是什么函数，还有一个办法：通过<code>name</code>属性，从实例得到构造函数的名称。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Foo</span><span style="color: #E1E4E8">() {}</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> f </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Foo</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">f.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8">.name; </span><span style="color: #6A737D">// "Foo"</span></span></code></pre>
<h3 id="2instanceof-运算符">2、instanceof 运算符</h3>
<p><code>instanceof</code>运算符，<strong>判断对象是否为某个构造函数的实例，返回一个布尔值</strong>。</p>
<h4 id="语法-3">语法</h4>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">&#x3C;</span><span style="color: #79B8FF">实例对象</span><span style="color: #E1E4E8">> instanceof &#x3C;</span><span style="color: #79B8FF">构造函数</span><span style="color: #E1E4E8">></span></span></code></pre>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #e1e4e8">var v = new Vehicle();</span></span>
<span class="line"><span style="color: #e1e4e8">v instanceof Vehicle // true   v是构造函数Vehicel的实例</span></span></code></pre>
<p>上面代码中，对象<code>v</code>是构造函数<code>Vehicle</code>的实例，所以返回<code>true</code>。</p>
<p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会<strong>检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上</strong>。因此，下面两种写法是等价的。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">v </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Vehicle</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #6A737D">// 等同于</span></span>
<span class="line"><span style="color: #79B8FF">Vehicle</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">isPrototypeOf</span><span style="color: #E1E4E8">(v);</span></span></code></pre>
<p>上面代码中，<code>Object.prototype.isPrototypeOf</code>的详细解释见后文。</p>
<p>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> d </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Date</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">d </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Date</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #E1E4E8">d </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Object</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span></code></pre>
<p>上面代码中，<code>d</code>同时是<code>Date</code>和<code>Object</code>的实例，因此对这两个构造函数都返回<code>true</code>。</p>
<p>由于<strong>任意对象（除了<code>null</code>）都是<code>Object</code>的实例</strong>，所以<code>instanceof</code>运算符可以判断一个值是否为非<code>null</code>的对象。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> { foo: </span><span style="color: #79B8FF">123</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #E1E4E8">obj </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Object</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">null</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Object</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// false</span></span></code></pre>
<p>上面代码中，除了<code>null</code>，其他对象的<code>instanceOf Object</code>的运算结果都是<code>true</code>。</p>
<p><code>instanceof</code>的原理是检查右边构造函数的<code>prototype</code>属性，是否在左边对象的原型链上。有一种<strong>特殊情况</strong>，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #F97583">typeof</span><span style="color: #E1E4E8"> obj; </span><span style="color: #6A737D">// "object"</span></span>
<span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Object</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// false</span></span></code></pre>
<p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create</code>的详细介绍见后文）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。但是，<strong>只要一个对象的原型不是<code>null</code>，<code>instanceof</code>运算符的判断就不会失真</strong>。</p>
<h4 id="用处">用处</h4>
<p><code>instanceof</code>运算符的一个用处，是<strong>判断值的类型</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> x </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">3</span><span style="color: #E1E4E8">];</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> y </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {};</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">z</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {};</span></span>
<span class="line"><span style="color: #E1E4E8">x </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Array</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #E1E4E8">y </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Object</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #E1E4E8">y </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Function</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span></code></pre>
<p>上面代码中，<code>instanceof</code>运算符判断，变量<code>x</code>是数组，变量<code>y</code>是对象，变量<code>z</code>是函数。</p>
<p>注意，<code>instanceof</code>运算符<strong>只能用于对象</strong>，<strong>不适用原始类型的值</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> s </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"hello"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> z </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">s </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">String</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// false</span></span>
<span class="line"><span style="color: #E1E4E8">z </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Number</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// false</span></span>
<span class="line"><span style="color: #6A737D">// 原始类型并没有实例化，所有都返回false</span></span></code></pre>
<p>上面代码中，字符串不是<code>String</code>对象的实例（因为字符串不是对象），所以返回<code>false</code>。</p>
<p>此外，对于<code>undefined</code>和<code>null</code>，<code>instanceof</code>运算符总是返回<code>false</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #79B8FF">undefined</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Object</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// false</span></span>
<span class="line"><span style="color: #79B8FF">null</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Object</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// false</span></span></code></pre>
<p>利用<code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，<strong>忘了加<code>new</code>命令的问题</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Fubar</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">foo</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">bar</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Fubar</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">// 忘加new命令时 this为 全局对象window</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">._foo </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> foo;</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">._bar </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> bar;</span></span>
<span class="line"><span style="color: #E1E4E8">  } </span><span style="color: #F97583">else</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Fubar</span><span style="color: #E1E4E8">(foo, bar);</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #B392F0">Fubar</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">_foo</span><span style="color: #E1E4E8">(</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 1</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Fubar</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">)._foo; </span><span style="color: #6A737D">// 1</span></span></code></pre>
<p>上面代码使用<code>instanceof</code>运算符，在函数体内部判断<code>this</code>关键字是否为构造函数<code>Fubar</code>的实例。如果不是，就表明忘了加<code>new</code>命令。</p>
<h3 id="3构造函数的继承">3、构造函数的继承</h3>
<p><strong>让一个构造函数继承另一个构造函数</strong>，是非常常见的需求。</p>
<p>这可以分成两步实现。<strong>第一步是在子类的构造函数中，调用父类的构造函数</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Sub</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">value</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// Sub是子类构造函数</span></span>
<span class="line"><span style="color: #E1E4E8">  Super.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// Super是父类构造函数，这的this是子类的实例</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.prop </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> value;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面代码中，<code>Sub</code>是子类的构造函数，<code>this</code>是子类的实例。在实例上调用父类的构造函数<code>Super</code>，<strong>就会让子类实例具有父类实例的属性</strong>。</p>
<p><strong>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</strong></p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 子类的原型指向一个新对象，新对象原型指向父类原型，等于子类原型继承了父类原型，且对子类原型操作不会影响到父类原型</span></span>
<span class="line"><span style="color: #79B8FF">Sub</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">Super</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #79B8FF">Sub</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Sub;</span></span>
<span class="line"><span style="color: #79B8FF">Sub</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.method </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"..."</span><span style="color: #E1E4E8">;</span></span></code></pre>
<p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为<code>Object.create(Super.prototype)</code>，而不是直接等于<code>Super.prototype</code>。否则后面两行对<code>Sub.prototype</code>的操作，会连父类的原型<code>Super.prototype</code>一起修改掉。</p>
<p><strong>另外一种写法</strong>是<code>Sub.prototype</code>等于一个父类实例。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #79B8FF">Sub</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Super</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 这个写法会继承父类实例的方法，不推荐</span></span></code></pre>
<p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以<strong>不推荐</strong>使用这种写法。</p>
<p>举例来说，下面是一个<code>Shape</code>构造函数。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Shape</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.x </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.y </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">Shape</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">move</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">x</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">y</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.x </span><span style="color: #F97583">+=</span><span style="color: #E1E4E8"> x;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.y </span><span style="color: #F97583">+=</span><span style="color: #E1E4E8"> y;</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">info</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"Shape moved."</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>我们需要让<code>Rectangle</code>构造函数继承<code>Shape</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 第一步，子类继承父类的实例</span></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Rectangle</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  Shape.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 调用父类构造函数</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #6A737D">// 另一种写法</span></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Rectangle</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.base </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Shape;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">base</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 第二步，子类继承父类的原型</span></span>
<span class="line"><span style="color: #79B8FF">Rectangle</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">Shape</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #79B8FF">Rectangle</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Rectangle;</span></span></code></pre>
<p>采用这样的写法以后，<code>instanceof</code>运算符会对子类和父类的构造函数，都返回<code>true</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> rect </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Rectangle</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">rect </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Rectangle</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #E1E4E8">rect </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Shape</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span></code></pre>
<p>上面代码中，子类是整体继承父类。有时只需要<strong>单个方法的继承</strong>，这时可以采用下面的写法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #79B8FF">ClassB</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">print</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 单个方法的继承</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">ClassA</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.print.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 继承了ClassA的print方法</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// some code</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>上面代码中，子类<code>B</code>的<code>print</code>方法先调用父类<code>A</code>的<code>print</code>方法，再部署自己的代码。这就等于继承了父类<code>A</code>的<code>print</code>方法。</p>
<h3 id="4多重继承">4、多重继承</h3>
<p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">M1</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 构造函数M1</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.hello </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"hello"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">M2</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 构造函数M2</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.world </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"world"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">S</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 子类构造函数S</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">M1</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">M2</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 继承 M1</span></span>
<span class="line"><span style="color: #79B8FF">S</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">M1</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #6A737D">// 继承链上加入 M2</span></span>
<span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">assign</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">S</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">, </span><span style="color: #79B8FF">M2</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 指定构造函数</span></span>
<span class="line"><span style="color: #79B8FF">S</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">S</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> s </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">S</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">s.hello; </span><span style="color: #6A737D">// 'hello'</span></span>
<span class="line"><span style="color: #E1E4E8">s.world; </span><span style="color: #6A737D">// 'world'</span></span></code></pre>
<p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）。</p>
<h3 id="5模块">5、模块</h3>
<p>随着网站逐渐变成“互联网应用程序”，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。</p>
<p><strong>JavaScript 模块化编程</strong>，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。</p>
<h4 id="1基本的实现方法">（1）基本的实现方法</h4>
<p><strong>模块是实现特定功能的一组属性和方法的封装。</strong></p>
<p>简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> module1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Object</span><span style="color: #E1E4E8">({</span></span>
<span class="line"><span style="color: #E1E4E8">  _count: </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">m1</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">//...</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">m2</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">//...</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">});</span></span></code></pre>
<p>上面的函数<code>m1</code>和<code>m2</code>，都封装在<code>module1</code>对象里。使用的时候，就是调用这个对象的属性。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 使用</span></span>
<span class="line"><span style="color: #E1E4E8">module1.</span><span style="color: #B392F0">m1</span><span style="color: #E1E4E8">();</span></span></code></pre>
<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">module1._count </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">5</span><span style="color: #E1E4E8">;</span></span></code></pre>
<h4 id="2封装私有变量">（2）封装私有变量</h4>
<h5 id="2-1构造函数的写法">（2-1）构造函数的写法</h5>
<p>我们可以利用构造函数，封装私有变量。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">StringBuilder</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> buffer </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> []; </span><span style="color: #6A737D">// 模块的私有变量</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">add</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">str</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    buffer.</span><span style="color: #B392F0">push</span><span style="color: #E1E4E8">(str);</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">toString</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> buffer.</span><span style="color: #B392F0">join</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">""</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面代码中，<code>buffer</code>是模块的私有变量。一旦生成实例对象，外部是无法直接访问<code>buffer</code>的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">StringBuilder</span><span style="color: #E1E4E8">() {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">._buffer </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [];</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">StringBuilder</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  constructor: StringBuilder,</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">add</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">str</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">._buffer.</span><span style="color: #B392F0">push</span><span style="color: #E1E4E8">(str);</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">toString</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">._buffer.</span><span style="color: #B392F0">join</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">""</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。</p>
<h5 id="2-2立即执行函数的写法">（2-2）立即执行函数的写法</h5>
<p>另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> module1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> _count </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">m1</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">//...</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">m2</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">//...</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    m1: m1,</span></span>
<span class="line"><span style="color: #E1E4E8">    m2: m2,</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"><span style="color: #E1E4E8">})();</span></span></code></pre>
<p>使用上面的写法，外部代码无法读取内部的<code>_count</code>变量。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">console.</span><span style="color: #B392F0">info</span><span style="color: #E1E4E8">(module1._count); </span><span style="color: #6A737D">//undefined</span></span></code></pre>
<p>上面的<code>module1</code>就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。</p>
<h4 id="3模块的放大模式向模块添加新方法">（3）模块的放大模式（向模块添加新方法）</h4>
<p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> module1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">mod</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  mod.</span><span style="color: #B392F0">m3</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">//...</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> mod;</span></span>
<span class="line"><span style="color: #E1E4E8">})(module1);</span></span></code></pre>
<p>上面的代码为<code>module1</code>模块添加了一个新方法<code>m3()</code>，然后返回新的<code>module1</code>模块。</p>
<p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> module1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">mod</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">//...</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> mod;</span></span>
<span class="line"><span style="color: #E1E4E8">})(window.module1 </span><span style="color: #F97583">||</span><span style="color: #E1E4E8"> {});</span></span></code></pre>
<p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。</p>
<h4 id="4输入全局变量保证独立性">（4）输入全局变量（保证独立性）</h4>
<p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</p>
<p>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> module1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">$</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">YAHOO</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">//...</span></span>
<span class="line"><span style="color: #E1E4E8">})(jQuery, </span><span style="color: #79B8FF">YAHOO</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 向模块内部传入全局变量</span></span></code></pre>
<p>上面的<code>module1</code>模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入<code>module1</code>。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>
<p><strong>立即执行函数还可以起到命名空间的作用</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">(</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">$</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">window</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">document</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">go</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">num</span><span style="color: #E1E4E8">) {}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">handleEvents</span><span style="color: #E1E4E8">() {}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">initialize</span><span style="color: #E1E4E8">() {}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">dieCarouselDie</span><span style="color: #E1E4E8">() {}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">//attach to the global scope</span></span>
<span class="line"><span style="color: #E1E4E8">  window.finalCarousel </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">// 对外暴露接口</span></span>
<span class="line"><span style="color: #E1E4E8">    init: initialize,</span></span>
<span class="line"><span style="color: #E1E4E8">    destroy: dieCarouselDie,</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"><span style="color: #E1E4E8">})(jQuery, window, document);</span></span></code></pre>
<p>上面代码中，<code>finalCarousel</code>对象输出到全局，对外暴露<code>init</code>和<code>destroy</code>接口，<strong>内部方法<code>go</code>、<code>handleEvents</code>、<code>initialize</code>、<code>dieCarouselDie</code>都是外部无法调用的</strong>。</p>
<h2 id="四object-对象的相关方法">四、Object 对象的相关方法</h2>
<p>JavaScript 在<code>Object</code>对象上面，提供了很多相关方法，处理面向对象编程的相关操作。本章介绍这些方法。</p>
<h3 id="1objectgetprototypeof-获取原型对象">1、Object.getPrototypeOf() 获取原型对象</h3>
<p><code>Object.getPrototypeOf</code>方法<strong>返回参数对象的原型</strong>。这是获取原型对象的标准方法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">F</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {};</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> f </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">F</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">getPrototypeOf</span><span style="color: #E1E4E8">(f) </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">F</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span></code></pre>
<p>上面代码中，实例对象<code>f</code>的原型是<code>F.prototype</code>。</p>
<p>下面是几种特殊对象的原型。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 空对象的原型是 Object.prototype</span></span>
<span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">getPrototypeOf</span><span style="color: #E1E4E8">({}) </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">Object</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// Object.prototype 的原型是 null</span></span>
<span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">getPrototypeOf</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">Object</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 函数的原型是 Function.prototype</span></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">f</span><span style="color: #E1E4E8">() {}</span></span>
<span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">getPrototypeOf</span><span style="color: #E1E4E8">(f) </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">Function</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span></code></pre>
<h3 id="2objectsetprototypeof-设置原型对象">2、Object.setPrototypeOf() 设置原型对象</h3>
<p><code>Object.setPrototypeOf</code>方法为参数对象<strong>设置原型</strong>，<strong>返回该参数对象</strong>。它接受两个参数，第一个是现有对象，第二个是原型对象。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {};</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> b </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> { x: </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">setPrototypeOf</span><span style="color: #E1E4E8">(a, b);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">getPrototypeOf</span><span style="color: #E1E4E8">(a) </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> b; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #E1E4E8">a.x; </span><span style="color: #6A737D">// 1  a对象共享b对象的属性</span></span></code></pre>
<p>上面代码中，<code>Object.setPrototypeOf</code>方法将对象<code>a</code>的原型，设置为对象<code>b</code>，因此<code>a</code>可以共享<code>b</code>的属性。</p>
<h5 id="使用objectsetprototypeof方法模拟new命令"><strong>使用<code>Object.setPrototypeOf</code>方法模拟<code>new</code>命令</strong></h5>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">F</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.foo </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"bar"</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> f </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">F</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// 等同于</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> f </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">setPrototypeOf</span><span style="color: #E1E4E8">({}, </span><span style="color: #79B8FF">F</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 模拟new命令</span></span>
<span class="line"><span style="color: #79B8FF">F</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">call</span><span style="color: #E1E4E8">(f);</span></span></code></pre>
<p>上面代码中，<code>new</code>命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的<code>prototype</code>属性（上例是<code>F.prototype</code>）；第二步，将构造函数内部的<code>this</code>绑定这个空对象，然后执行构造函数，使得定义在<code>this</code>上面的方法和属性（上例是<code>this.foo</code>），都转移到这个空对象上。</p>
<h3 id="3-objectcreate-创建实例对象指向目标对象的原型">3、 Object.create() 创建实例对象，指向目标对象的原型</h3>
<p>生成实例对象的常用方法是，使用<code>new</code>命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？</p>
<p>JavaScript 提供了<code>Object.create</code>方法，用来满足这种需求。**该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。**该实例完全继承原型对象的属性。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// 原型对象</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">A</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">print</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">"hello"</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 实例对象</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">B</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">A</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 以A为原型，创建了B实例对象，使B继承了A的属性</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">getPrototypeOf</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">B</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">A</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #79B8FF">B</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">print</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// hello</span></span>
<span class="line"><span style="color: #79B8FF">B</span><span style="color: #E1E4E8">.print </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">A</span><span style="color: #E1E4E8">.print; </span><span style="color: #6A737D">// true</span></span></code></pre>
<p>上面代码中，<code>Object.create</code>方法以<code>A</code>对象为原型，生成了<code>B</code>对象。<code>B</code>继承了<code>A</code>的所有属性和方法。</p>
<p>实际上，<code>Object.create</code>方法可以用下面的代码代替。</p>
<h5 id="内部实现原理">内部实现原理</h5>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">typeof</span><span style="color: #E1E4E8"> Object.create </span><span style="color: #F97583">!==</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"function"</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">obj</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">// 模拟Object.create方法</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">F</span><span style="color: #E1E4E8">() {} </span><span style="color: #6A737D">// 创建一个空构造函数F</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">F</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> obj; </span><span style="color: #6A737D">// 让F的原型 指向参数obj（obj为传入的原型对象）</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">F</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 返回一个F的实例</span></span>
<span class="line"><span style="color: #E1E4E8">  };</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面代码表明，<code>Object.create</code>方法的实质是新建一个空的构造函数<code>F</code>，然后让<code>F.prototype</code>属性指向参数对象<code>obj</code>，最后返回一个<code>F</code>的实例，从而实现让该实例继承<code>obj</code>的属性。</p>
<p>下面三种方式生成的新对象是等价的。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">({});</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">Object</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj3 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Object</span><span style="color: #E1E4E8">();</span></span></code></pre>
<p>如果想要生成一个不继承任何属性（比如没有<code>toString</code>和<code>valueOf</code>方法）的对象，可以将<code>Object.create</code>的参数设为<code>null</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// 不继承Object的toString和valueOf方法的一个对象</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #B392F0">valueOf</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// TypeError: Object [object Object] has no method 'valueOf'</span></span></code></pre>
<p>上面代码中，对象<code>obj</code>的原型是<code>null</code>，它就不具备一些定义在<code>Object.prototype</code>对象上面的属性，比如<code>valueOf</code>方法。</p>
<p>使用<code>Object.create</code>方法的时候，必须提供对象原型，即<strong>参数不能为空，或者不是对象，否则会报错</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #6A737D">// TypeError: Object prototype may only be an Object or null</span></span>
<span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">123</span><span style="color: #E1E4E8">);</span></span>
<span class="line"><span style="color: #6A737D">// TypeError: Object prototype may only be an Object or null</span></span></code></pre>
<p><code>Object.create</code>方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> { p: </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(obj1);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">obj1.p </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">obj2.p; </span><span style="color: #6A737D">// 2  obj2的原型指向obj1，当访问obj2上的p属性时，js引擎会先在obj2本身上找，没找到会去原型上找</span></span></code></pre>
<p>上面代码中，修改对象原型<code>obj1</code>会影响到实例对象<code>obj2</code>。</p>
<p>除了对象的原型，<code>Object.create</code>方法还可以接受<strong>第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span></span>
<span class="line"><span style="color: #E1E4E8">  {},</span></span>
<span class="line"><span style="color: #E1E4E8">  {</span></span>
<span class="line"><span style="color: #E1E4E8">    p1: {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #6A737D">// p1为添加到obj实例对象自身的属性</span></span>
<span class="line"><span style="color: #E1E4E8">      value: </span><span style="color: #79B8FF">123</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">      enumerable: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">      configurable: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">      writable: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">    },</span></span>
<span class="line"><span style="color: #E1E4E8">    p2: {</span></span>
<span class="line"><span style="color: #E1E4E8">      value: </span><span style="color: #9ECBFF">"abc"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">      enumerable: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">      configurable: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">      writable: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">    },</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 等同于</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">({});</span></span>
<span class="line"><span style="color: #E1E4E8">obj.p1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">123</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">obj.p2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"abc"</span><span style="color: #E1E4E8">;</span></span></code></pre>
<p><code>Object.create</code>方法生成的对象，<strong>继承了它的原型对象的构造函数</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">A</span><span style="color: #E1E4E8">() {}</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">A</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> b </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(a);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">b.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">A</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #E1E4E8">b </span><span style="color: #F97583">instanceof</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">A</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// true</span></span></code></pre>
<p>上面代码中，<code>b</code>对象的原型是<code>a</code>对象，因此继承了<code>a</code>对象的构造函数<code>A</code>。</p>
<h3 id="4objectprototypeisprototypeof判断某个对象是否为参数对象的原型">4、Object.prototype.isPrototypeOf()判断某个对象是否为参数对象的原型</h3>
<p>实例对象的<code>isPrototypeOf</code>方法，用来<strong>判断该对象是否为参数对象的原型</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {};</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(o1);</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o3 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(o2);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">o2.</span><span style="color: #B392F0">isPrototypeOf</span><span style="color: #E1E4E8">(o3); </span><span style="color: #6A737D">// true  判断o2是否为o3的原型</span></span>
<span class="line"><span style="color: #E1E4E8">o1.</span><span style="color: #B392F0">isPrototypeOf</span><span style="color: #E1E4E8">(o3); </span><span style="color: #6A737D">// true  判断o1是否为o3的原型</span></span></code></pre>
<p>上面代码中，<code>o1</code>和<code>o2</code>都是<code>o3</code>的原型。这表明只要实例对象处在参数对象的原型链上，<code>isPrototypeOf</code>方法都返回<code>true</code>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #79B8FF">Object</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">isPrototypeOf</span><span style="color: #E1E4E8">({}); </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #79B8FF">Object</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">isPrototypeOf</span><span style="color: #E1E4E8">([]); </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #79B8FF">Object</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">isPrototypeOf</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">/</span><span style="color: #DBEDFF">xyz</span><span style="color: #9ECBFF">/</span><span style="color: #E1E4E8">); </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #79B8FF">Object</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">isPrototypeOf</span><span style="color: #E1E4E8">(Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">null</span><span style="color: #E1E4E8">)); </span><span style="color: #6A737D">// false</span></span></code></pre>
<p>上面代码中，由于<code>Object.prototype</code>处于原型链的最顶端，所以对各种实例都返回<code>true</code>，只有直接继承自<code>null</code>的对象除外。</p>
<h3 id="5objectprototype__proto__-返回该对象的原型可读写">5、Object.prototype.__proto__ 返回该对象的原型，可读写</h3>
<p>实例对象的<code>__proto__</code><strong>属性</strong>（前后各两个下划线），<strong>返回该对象的原型。该属性可读写</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">({ x: </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8"> }); </span><span style="color: #6A737D">// 创建实例对象obj，其原型指定为{x:1}</span></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #79B8FF">__proto__</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// {x: 1}  实例对象obj的__proto__属性，返回obj的原型</span></span>
<span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">getPrototypeOf</span><span style="color: #E1E4E8">(obj); </span><span style="color: #6A737D">// {x: 1}</span></span></code></pre>
<p>上面代码通过<code>Object.create</code>创建实例对象 obj，指定其原型为<code>{x:1}</code>，访问 obj 对象的<code>__proto__</code>属性，返回其原型。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {};</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> p </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #79B8FF">__proto__</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> p; </span><span style="color: #6A737D">// 原型属性可读写</span></span>
<span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">getPrototypeOf</span><span style="color: #E1E4E8">(obj) </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> p; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #79B8FF">__proto__</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">getPrototypeOf</span><span style="color: #E1E4E8">(obj); </span><span style="color: #6A737D">//true</span></span></code></pre>
<p>上面代码通过<code>__proto__</code>属性，将<code>p</code>对象设为<code>obj</code>对象的原型。</p>
<p>根据语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。<strong>因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>，进行原型对象的读写操作</strong>。</p>
<p>原型链可以用<code>__proto__</code>很直观地表示。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">A</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  name: </span><span style="color: #9ECBFF">"张三"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">B</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  name: </span><span style="color: #9ECBFF">"李四"</span><span style="color: #E1E4E8">,</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> proto </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">print</span><span style="color: #E1E4E8">: </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">this</span><span style="color: #E1E4E8">.name);</span></span>
<span class="line"><span style="color: #E1E4E8">  },</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">A</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">__proto__</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> proto; </span><span style="color: #6A737D">// 将A的原型指向proto对象</span></span>
<span class="line"><span style="color: #79B8FF">B</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">__proto__</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> proto; </span><span style="color: #6A737D">// 将B的原型指向proto对象</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// 共享print方法，都是在调用proto对象内的print方法</span></span>
<span class="line"><span style="color: #79B8FF">A</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">print</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 张三</span></span>
<span class="line"><span style="color: #79B8FF">B</span><span style="color: #E1E4E8">.</span><span style="color: #B392F0">print</span><span style="color: #E1E4E8">(); </span><span style="color: #6A737D">// 李四</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">A</span><span style="color: #E1E4E8">.print </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">B</span><span style="color: #E1E4E8">.print; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #79B8FF">A</span><span style="color: #E1E4E8">.print </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> proto.print; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #79B8FF">B</span><span style="color: #E1E4E8">.print </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> proto.print; </span><span style="color: #6A737D">// true</span></span></code></pre>
<p>上面代码中，<code>A</code>对象和<code>B</code>对象的原型都是<code>proto</code>对象，它们都共享<code>proto</code>对象的<code>print</code>方法。也就是说，<code>A</code>和<code>B</code>的<code>print</code>方法，都是在调用<code>proto</code>对象的<code>print</code>方法。</p>
<h3 id="6获取原型对象方法的比较">6、获取原型对象方法的比较</h3>
<p>如前所述，<code>__proto__</code>属性指向当前对象的原型对象，即构造函数的<code>prototype</code>属性。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Object</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #79B8FF">__proto__</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">Object</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #E1E4E8">obj.</span><span style="color: #79B8FF">__proto__</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> obj.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #6A737D">// true</span></span></code></pre>
<p>上面代码首先新建了一个对象<code>obj</code>，它的<code>__proto__</code>属性，指向构造函数（<code>Object</code>或<code>obj.constructor</code>）的<code>prototype</code>属性。</p>
<p>因此，获取实例对象<code>obj</code>的原型对象，有三种方法。</p>
<ul>
<li><code>obj.__proto__</code></li>
<li><code>obj.constructor.prototype</code></li>
<li><code>Object.getPrototypeOf(obj)</code></li>
</ul>
<p>上面三种方法之中，前两种都不是很可靠。<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以不部署。而<code>obj.constructor.prototype</code>在手动改变原型对象时，可能会失效。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">P</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {};</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> p </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">P</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">C</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> () {};</span></span>
<span class="line"><span style="color: #79B8FF">C</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> p;</span></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> c </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">C</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">c.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> p; </span><span style="color: #6A737D">// false</span></span></code></pre>
<p>上面代码中，构造函数<code>C</code>的原型对象被改成了<code>p</code>，但是实例对象的<code>c.constructor.prototype</code>却没有指向<code>p</code>。所以，在改变原型对象时，一般要同时设置<code>constructor</code>属性。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #79B8FF">C</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> p;</span></span>
<span class="line"><span style="color: #79B8FF">C</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">C</span><span style="color: #E1E4E8">; </span><span style="color: #6A737D">// 如在构造函数的继承中就使用到这个操作</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> c </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">C</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">c.</span><span style="color: #79B8FF">constructor</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">prototype</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> p; </span><span style="color: #6A737D">// true</span></span></code></pre>
<p>因此，<strong>推荐使用第三种<code>Object.getPrototypeOf</code>方法，获取原型对象</strong>。</p>
<h3 id="7objectgetownpropertynames">7、Object.getOwnPropertyNames()</h3>
<p><code>Object.getOwnPropertyNames</code>方法<strong>返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">getOwnPropertyNames</span><span style="color: #E1E4E8">(Date);</span></span>
<span class="line"><span style="color: #6A737D">// ["parse", "arguments", "UTC", "caller", "name", "prototype", "now", "length"]</span></span></code></pre>
<p>上面代码中，<code>Object.getOwnPropertyNames</code>方法返回<code>Date</code>所有自身的属性名。</p>
<p>对象本身的属性之中，有的是可以遍历的（enumerable），有的是不可以遍历的。<code>Object.getOwnPropertyNames</code>方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用<code>Object.keys</code>方法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">Object.</span><span style="color: #B392F0">keys</span><span style="color: #E1E4E8">(Date); </span><span style="color: #6A737D">// []</span></span></code></pre>
<p>上面代码表明，<code>Date</code>对象所有自身的属性，都是不可以遍历的。</p>
<h3 id="8objectprototypehasownproperty">8、Object.prototype.hasOwnProperty()</h3>
<p>对象实例的<code>hasOwnProperty</code>方法返回一个布尔值，用于<strong>判断某个属性定义在对象自身，还是定义在原型链上</strong>。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #e1e4e8">Date.hasOwnProperty('length') // true</span></span>
<span class="line"><span style="color: #e1e4e8">Date.hasOwnProperty('toString') // false</span></span></code></pre>
<p>上面代码表明，<code>Date.length</code>（构造函数<code>Date</code>可以接受多少个参数）是<code>Date</code>自身的属性，<code>Date.toString</code>是继承的属性。</p>
<p>另外，<code>hasOwnProperty</code>方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。</p>
<h3 id="9in-运算符和-forin-循环">9、in 运算符和 for…in 循环</h3>
<p><code>in</code>运算符<strong>返回一个布尔值，表示一个对象是否具有某个属性</strong>。它不区分该属性是对象自身的属性，还是继承的属性。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #9ECBFF">"length"</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">in</span><span style="color: #E1E4E8"> Date; </span><span style="color: #6A737D">// true</span></span>
<span class="line"><span style="color: #9ECBFF">"toString"</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">in</span><span style="color: #E1E4E8"> Date; </span><span style="color: #6A737D">// true</span></span></code></pre>
<p><code>in</code>运算符常用于检查一个属性是否存在。</p>
<p>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用<code>for...in</code>循环。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> { p1: </span><span style="color: #79B8FF">123</span><span style="color: #E1E4E8"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">var</span><span style="color: #E1E4E8"> o2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(o1, {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// o2的原型指向o1，并且在o2上定义一个属性p2</span></span>
<span class="line"><span style="color: #E1E4E8">  p2: { value: </span><span style="color: #9ECBFF">"abc"</span><span style="color: #E1E4E8">, enumerable: </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8"> },</span></span>
<span class="line"><span style="color: #E1E4E8">});</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (p </span><span style="color: #F97583">in</span><span style="color: #E1E4E8"> o2) {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">info</span><span style="color: #E1E4E8">(p);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"><span style="color: #6A737D">// p2</span></span>
<span class="line"><span style="color: #6A737D">// p1    继承的属性</span></span></code></pre>
<p>上面代码中，对象<code>o2</code>的<code>p2</code>属性是自身的，<code>p1</code>属性是继承的。这两个属性都会被<code>for...in</code>循环遍历。</p>
<p>为了在<code>for...in</code>循环中获得对象自身的属性，可以采用<code>hasOwnProperty</code>方法判断一下。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> name </span><span style="color: #F97583">in</span><span style="color: #E1E4E8"> object) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (object.</span><span style="color: #B392F0">hasOwnProperty</span><span style="color: #E1E4E8">(name)) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">// 过滤掉非自身的属性</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">/* loop code */</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p><strong>获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举）</strong>，可以使用下面的函数。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">inheritedPropertyNames</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">obj</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> props </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {};</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">while</span><span style="color: #E1E4E8"> (obj) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">// 获取obj对象的所有属性，包括不可枚举的，</span></span>
<span class="line"><span style="color: #E1E4E8">    Object.</span><span style="color: #B392F0">getOwnPropertyNames</span><span style="color: #E1E4E8">(obj).</span><span style="color: #B392F0">forEach</span><span style="color: #E1E4E8">(</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">p</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">      props[p] </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">true</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">    });</span></span>
<span class="line"><span style="color: #E1E4E8">    obj </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">getPrototypeOf</span><span style="color: #E1E4E8">(obj); </span><span style="color: #6A737D">// 获取对象的原型</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(props);</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">getOwnPropertyNames</span><span style="color: #E1E4E8">(props);</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>上面代码依次获取<code>obj</code>对象的每一级原型对象“自身”的属性，从而获取<code>obj</code>对象的“所有”属性，不管是否可遍历。</p>
<p>下面是一个例子，列出<code>Date</code>对象的所有属性。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">inheritedPropertyNames</span><span style="color: #E1E4E8">(Date);</span></span>
<span class="line"><span style="color: #6A737D">// [</span></span>
<span class="line"><span style="color: #6A737D">//  "caller",</span></span>
<span class="line"><span style="color: #6A737D">//  "constructor",</span></span>
<span class="line"><span style="color: #6A737D">//  "toString",</span></span>
<span class="line"><span style="color: #6A737D">//  "UTC",</span></span>
<span class="line"><span style="color: #6A737D">//  ...</span></span>
<span class="line"><span style="color: #6A737D">// ]</span></span></code></pre>
<h3 id="10对象的拷贝">10、对象的拷贝</h3>
<p>如果要拷贝一个对象，需要做到下面两件事情。</p>
<ul>
<li>确保拷贝后的对象，与原对象具有同样的原型。</li>
<li>确保拷贝后的对象，与原对象具有同样的实例属性。</li>
</ul>
<p>下面就是根据上面两点，实现的对象拷贝函数。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">copyObject</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">orig</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 拷贝对象函数</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 创建一个新对象，新对象的原型指向旧对象的原型</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> copy </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(Object.</span><span style="color: #B392F0">getPrototypeOf</span><span style="color: #E1E4E8">(orig));</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">copyOwnPropertiesFrom</span><span style="color: #E1E4E8">(copy, orig);</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> copy;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">copyOwnPropertiesFrom</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">target</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">source</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 拷贝旧对象的实例属性</span></span>
<span class="line"><span style="color: #E1E4E8">  Object.</span><span style="color: #B392F0">getOwnPropertyNames</span><span style="color: #E1E4E8">(source).</span><span style="color: #B392F0">forEach</span><span style="color: #E1E4E8">(</span><span style="color: #F97583">function</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">propKey</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">// 获取每个属性的 属性描述对象</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">var</span><span style="color: #E1E4E8"> desc </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">getOwnPropertyDescriptor</span><span style="color: #E1E4E8">(source, propKey);</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">// 定义属性，给target对象定义propKey属性，其属性描述对象是desc</span></span>
<span class="line"><span style="color: #E1E4E8">    Object.</span><span style="color: #B392F0">defineProperty</span><span style="color: #E1E4E8">(target, propKey, desc);</span></span>
<span class="line"><span style="color: #E1E4E8">  });</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> target;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>另一种更简单的写法，是利用 ES2017 才引入标准的<code>Object.getOwnPropertyDescriptors</code>方法。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">function</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">copyObject</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">orig</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> Object.</span><span style="color: #B392F0">create</span><span style="color: #E1E4E8">(</span></span>
<span class="line"><span style="color: #E1E4E8">    Object.</span><span style="color: #B392F0">getPrototypeOf</span><span style="color: #E1E4E8">(orig),</span></span>
<span class="line"><span style="color: #E1E4E8">    Object.</span><span style="color: #B392F0">getOwnPropertyDescriptors</span><span style="color: #E1E4E8">(orig)</span></span>
<span class="line"><span style="color: #E1E4E8">  );</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<h2 id="五严格模式">五、严格模式</h2>
<p>除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。</p>
<p>同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。</p>
<h3 id="1设计目的">1、设计目的</h3>
<p>早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。</p>
<p>严格模式是从 ES5 进入标准的，主要目的有以下几个。</p>
<ul>
<li>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</li>
<li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</li>
<li>提高编译器效率，增加运行速度。</li>
<li>为未来新版本的 JavaScript 语法做好铺垫。</li>
</ul>
<p>总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。</p>
<h3 id="2启用方法">2、启用方法</h3>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #9ECBFF">"use strict"</span><span style="color: #E1E4E8">;</span></span></code></pre>
				
	</section>
</article>
			</div>
		</main>
	</body></html>